<!DOCTYPE html>
<html>

<head>
    <title>Radiation 3D prototype</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
        }

        #functionbox {
            width: 250px;
            height: auto;
            position: absolute;
            top: 50px;
            bottom: 10px;
            left: 10px;
            z-index: 100;

            background-color: #b5cea8;
            background-color: #4444447e;
            border-radius: 4px;
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
        }

        #renderbody {
            width: 100%;
            height: 100vh;
        }

        #deleteplane {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #deleteplane:hover {
            background: #007e7a;
        }

        #deleteplane:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }

        .custom-file-upload {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: 22px;
            padding: 8px 16px;
            background: #00a19b;
            width: 168px;
            height: 32px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        .custom-file-upload:hover {
            background-color: #007e7a;
        }

        .custom-file-upload:active {
            transform: scale(0.97);
        }

        #addplane {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #addplane:hover {
            background: #007e7a;
        }

        #top {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 400;
            font-size: large;
            padding: 8px 16px;
            background: #00a19b;
            width: 60px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #top:hover {
            background: #007e7a;
        }

        #front {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: large;
            padding: 8px 16px;
            background: #00a19b;
            width: 60px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #front:hover {
            background: #007e7a;
        }

        #side {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 400;
            font-size: large;
            padding: 8px 16px;
            background: #00a19b;
            width: 60px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #side:hover {
            background: #007e7a;
        }

        #perspective {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #perspective:hover {
            background: #007e7a;
        }

        #renderbody {
            position: relative;
            width: 100%;
            height: 100vh;
            margin: 0;
            padding: 0;
        }

        /* Add this to your existing style section */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
        }

        #valueDisplay {
            position: fixed;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            pointer-events: none;
            font-family: Arial, sans-serif;
            font-size: 14px;
            z-index: 1001;
            white-space: nowrap;
        }

        .modal-content {
            display: block;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transform-origin: center center;
            transition: transform 0.1s ease-out;
            cursor: zoom-in;
            max-width: 90vw;
            max-height: 90vh;
        }

        .close {
            position: absolute;
            top: 15px;
            right: 35px;
            color: white;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
        }

        #scalinginput, #gridSizeInput {
            padding: 6px 8px;
            font-size: 20px;
            font-family: 'Poppins', sans-serif;
            border: 1px solid #ccc;
            border-radius: 8px;
            outline: none;
            margin-left: 25px;
            width: 200px;
            max-width: 185px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
        }

        #scalinginput:placeholder, #gridSizeInput:placeholder {
            color: #aaa;
        }

        #scalinginput:focus, #gridSizeInput:focus {
            border-color: #4a90e2;
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.2);
        }

        #scalingbutton {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #scalingbutton:hover {
            background: #007e7a;
        }

        #updatescale {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #updatescale:hover {
            background: #007e7a;
        }

        #exportBtn {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #exportBtn:hover {
            background: #007e7a;
        }

        #resetPlane {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #resetPlane:hover {
            background: #007e7a;
        }


        #importbtn {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: 24px;
            padding: 8px 16px;
            background: #00a19b;
            width: 168px;
            height: 32px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #importbtn:hover {
            background-color: #007e7a;
        }

        #importbtn:active {
            transform: scale(0.97);
        }

        #detail {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #detail:hover {
            background: #007e7a;
        }

        #calculate {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #calculate:hover {
            background: #007e7a;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            outline: none;
        }

        hr {
            border: none;
            border-top: 1px solid #444;
            margin: 10px 0;
        }

        p {
            font: bolder;
            font-size: 24px;
            font-family: 'Poppins', sans-serif;
            text-align: center;
            margin: 5px 0 10px 0;
            font-weight: bold;
            color: aliceblue;
        }

        .my-custom-gui {
            font-size: 26px;
            width: 700px;
            background-color: #222;
            border-radius: 10px;
            padding: 20px;
        }

        /* Bigger dat.GUI with your color scheme */
        .dg.main {
            font-family: 'Poppins', sans-serif !important;
            font-size: 20px !important;
            background-color: rgba(68, 68, 68, 0.8) !important;
            border-radius: 4px !important;
            width: 500px !important;
        }

        .dg .cr {
            height: 40px !important;
            line-height: 40px !important;
            border-bottom: 1px solid #444 !important;
        }

        .dg .c input[type=text] {
            height: 28px !important;
            font-size: 20px !important;
            background: #555 !important;
            color: white !important;
            border: 1px solid #666 !important;
            border-radius: 4px !important;
            font-family: 'Poppins', sans-serif;
            font: 700;
            width: 100% !important;
            margin-left: 0 !important;
        }

        .dg .c select {
            height: 34px !important;
            font-size: 20px !important;
            background: #555 !important;
            color: white !important;
            border: 1px solid #666 !important;
            border-radius: 4px !important;
            font-family: 'Poppins', sans-serif;
            font: 700;
            width: 102% !important;
            margin-left: -7px !important;
        }

        .dg .c select option {
            border-radius: 8px;
            padding: 4px 8px;
        }
        

        .dg .c .slider {
            display: none !important;
        }

        .dg .c .slider-fg {
            background: #00a19b !important;
            height: 24px !important;
        }

        .dg .c .slider:hover .slider-fg {
            background: #007e7a !important;
        }

        .dg .title {
            font-size: 18px !important;
            padding: 8px 10px !important;
            background-color: rgba(0, 161, 155, 0.3) !important;
        }

        .dg .cr.function .property-name {
            color: white !important;
            font-weight: 500 !important;
        }

        .dg .cr.function:hover {
            background: rgba(0, 161, 155, 0.2) !important;
        }

        .dg .cr.number .property-name,
        .dg .cr.boolean .property-name {
            color: white !important;
            font-weight: 500 !important;
        }

        /* Make checkbox bigger to fit the larger GUI */
        .dg .cr.boolean input[type="checkbox"] {
            width: 20px !important;
            height: 20px !important;
        }

        .dg .cr.boolean .checkbox {
            width: 20px !important;
            height: 20px !important;
        }

        .dg.main .close-button {
            display: none !important;
        }

        .dg.main .close-button:hover {
            background-color: #007e7a !important;
        }

        .view-buttons-container {
            display: flex;
            justify-content: center;
        }
    </style>

</head>

<body>

    <div id="functionbox">
        <p>Floor plan</p>
        <input type="file" id="imageInput" accept="image/*" hidden>
        <label for="imageInput" class="custom-file-upload">Upload Image</label>
        <hr>
        <p>Plane</p>
        <button id="addplane"> Add Plane </button>
        <button id="deleteplane">Delete Plane </button>
        <button id="resetPlane">Reset Plane</button>
        <hr>
        <p>Views</p>
        <div class="view-buttons-container">
            <button id="top">Top</button>
            <button id="front"> Front</button>
            <button id="side">Side</button>
        </div>
        <button id="perspective">Perspective</button>
        <hr>
        <p>Scaling</p>
        <input type="text" name="Set scale" id="scalinginput" placeholder="Enter the distance">
        <button id="scalingbutton"> Set scale </button>
        <button id="updatescale"> Update </button>
        <hr>
        <p>Precision</p>
        <input type="number" id="gridSizeInput" placeholder="Receiver grid size (1-50)" min="1" max="50">
        <hr>
        <p>Save</p>
        <button id="exportBtn"> Export Scene</button>
        <input type="file" id="importFile" accept=".json" hidden>
        <label for="importFile" id="importbtn"> Import Scene </label>
        <hr>
        <p>Calculation</p>
        <button id="detail">Show detail</button>
        <button id="calculate">Calculate</button>
        

    </div>
    <svg id="contour-svg" width="512" height="512" style="display:none;"></svg>
    <div id="renderbody"></div>
    <div id="contourModal" class="modal">
        <span class="close">&times;</span>
        <div id="valueDisplay"></div>
        <img id="contourImage" class="modal-content">
    </div>
    <svg id="contour-svg" width="512" height="512" style="display:none;"></svg>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.7/build/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-contour@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/lines/LineSegmentsGeometry.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/lines/LineSegments2.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/lines/LineGeometry.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/lines/LineMaterial.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/lines/Line2.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/renderers/CSS2DRenderer.js"></script>

    <script>



        // Add these variables near the top with your other variables
        let history = [];
        let groupDragStartPosition = null;
        let historyIndex = -1;
        const MAX_HISTORY_STEPS = 500; // Prevent memory bloat
        function initializeHistory() {
            // Capture initial state with all plane properties
            const initialState = planes.map(plane => ({
                id: plane.id || generateId(),
                position: plane.mesh.getWorldPosition(new THREE.Vector3()).clone(),
                rotation: plane.mesh.rotation.clone(),
                scale: plane.mesh.scale.clone(),
                width: plane.width,
                height: plane.height,
                // Store default values
                defaultWidth: plane.defaultWidth,
                defaultHeight: plane.defaultHeight,
                defaultX: plane.defaultX,
                defaultY: plane.defaultY,
                defaultZ: plane.defaultZ,
                defaultAngle: plane.defaultAngle,
                defaultColor: plane.defaultColor,
                // Store derived properties
                x: plane.x,
                y: plane.y,
                z: plane.z,
                angle: plane.angle,
                incline: plane.incline,
                color: plane.color,
                temperature: plane.temperature,
                type: plane.type,
                name: plane.name,
                selected: false,
                // Store material properties
                hasTexture: plane.mesh.material.map !== null,
                textureData: plane.mesh.material.map ? {
                    isContourTexture: plane.mesh.material.map.isContourTexture || false,
                    contourData: plane.mesh.material.map.contourData || null
                } : null
            }));

            history = [initialState];
            historyIndex = 0;
            console.log("Initial history state captured with full plane properties");
        }



        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                restoreState(historyIndex);
            } else {
                console.log("No more undo steps available.");
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                restoreState(historyIndex);
            } else {
                console.log("No more redo steps available.");
            }
        }

        // Replace the current keyboard event listener with this:
        window.addEventListener('keydown', (event) => {
            if (event.ctrlKey || event.metaKey) {
                if (event.key === 'z' && !event.shiftKey) {
                    undo();
                    event.preventDefault();
                } else if ((event.key === 'y' || (event.shiftKey && event.key === 'z'))) {
                    redo();
                    event.preventDefault();
                }
            }
        });

        // Add event listeners for buttons
        document.getElementById('undoBtn')?.addEventListener('click', undo);
        document.getElementById('redoBtn')?.addEventListener('click', redo);

        // Now we need to capture states at key moments. Add these calls:

        const scene = new THREE.Scene();
        scene.background = new THREE.Color("#222");


        //set up different camera parameters
        const frustumSize = 40;
        const cameras = {
            perspective: new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000),
            top: new THREE.OrthographicCamera(),
            front: new THREE.OrthographicCamera(),
            left: new THREE.OrthographicCamera()
        }

        cameras.perspective.position.set(10, 10, 10);
        cameras.top.position.set(0, 10, 0);
        cameras.top.lookAt(0, 0, 0);
        cameras.front.position.set(0, 0, 10);
        cameras.front.lookAt(0, 0, 0);
        cameras.left.position.set(-10, 0, 0);
        cameras.left.lookAt(0, 0, 0);

        for (const key in cameras) cameras[key].lookAt(0, 0, 0);
        let activeCamera = cameras.perspective;

        function updateOrthoCameras() {
            const aspect = window.innerWidth / window.innerHeight;
            for (const key of ['top', 'front', 'left']) {
                const cam = cameras[key];
                cam.left = frustumSize * aspect / -2; cam.right = frustumSize * aspect / 2;
                cam.top = frustumSize / 2; cam.bottom = frustumSize / -2;
                cam.near = 0.1; cam.far = 1000;
                cam.updateProjectionMatrix();
            }
        }

        updateOrthoCameras();

        document.getElementById('perspective').addEventListener('click', () => setView(cameras.perspective));
        document.getElementById('top').addEventListener('click', () => {
            setView(cameras.top)
        });
        document.getElementById('front').addEventListener('click', () => {
            setView(cameras.front)
        });
        document.getElementById('side').addEventListener('click', () => {
            setView(cameras.left)
        });

        // At the top with your other variables
        let selectedPlanes = []; // Array to store multiple selected planes
        let isShiftPressed = false; // Track shift key state
        // Add these near your other variables
        let selectedPlaneGroup = null; // Will store the temporary group
        let originalPositions = new Map(); // Stores original positions before grouping

        // Add these near your other event listeners (like the keydown for transform controls)
        window.addEventListener('keydown', (event) => {
            if (event.key === 'Shift') {
                isShiftPressed = true;
            }
        });

        window.addEventListener('keyup', (event) => {
            if (event.key === 'Shift') {
                isShiftPressed = false;
            }
        });


        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.shadowMap.enabled = true;
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById("renderbody").appendChild(renderer.domElement);


        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);


        // Add a grid (hidden by default)
        const grid = new THREE.GridHelper(50, 50, 0xffffff, 0xffffff);
        scene.add(grid);

        // Add CSS2DRenderer for axis labels
        const labelRenderer = new THREE.CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none';
        document.body.appendChild(labelRenderer.domElement);

        // Create axis indicator labels
        function createAxisLabel(text, position, color) {
            const labelDiv = document.createElement('div');
            labelDiv.textContent = text;
            labelDiv.style.color = '#ffffff'; // White text
            labelDiv.style.fontSize = '24px';
            labelDiv.style.fontWeight = 'bold';
            labelDiv.style.fontFamily = 'Arial, sans-serif';
            labelDiv.style.textShadow = '1px 1px 2px rgba(0,0,0,0.8)'; // Black shadow for contrast
            labelDiv.style.pointerEvents = 'none';
            
            const label = new THREE.CSS2DObject(labelDiv);
            label.position.copy(position);
            return label;
        }

        // Add axis labels (positioned further away)
        const xLabel = createAxisLabel('+X', new THREE.Vector3(70, 0, 0), '#ff0000');
        const xNegLabel = createAxisLabel('-X', new THREE.Vector3(-70, 0, 0), '#ff0000');
        const zLabel = createAxisLabel('+Z', new THREE.Vector3(0, 0, 70), '#0000ff');
        const zNegLabel = createAxisLabel('-Z', new THREE.Vector3(0, 0, -70), '#0000ff');

        scene.add(xLabel);
        scene.add(xNegLabel);
        scene.add(zLabel);
        scene.add(zNegLabel);

        // Add colorful axis lines
        function createAxisLine(origin, direction, color, length = 10) {
            const geometry = new THREE.BufferGeometry().setFromPoints([
                origin,
                new THREE.Vector3().copy(origin).add(direction.clone().multiplyScalar(length))
            ]);
            const material = new THREE.LineBasicMaterial({ 
                color: color, 
                linewidth: 5,
                depthTest: false,  // Disable depth testing to prevent z-fighting
                transparent: true,
                opacity: 0.8
            });
            const line = new THREE.Line(geometry, material);
            return line;
        }

        // Create axis lines (positioned slightly above grid to avoid z-fighting)
        const xAxis = createAxisLine(new THREE.Vector3(-70, 0.1, 0), new THREE.Vector3(1, 0, 0), 0xff0000, 140);
        const zAxis = createAxisLine(new THREE.Vector3(0, 0.1, -70), new THREE.Vector3(0, 0, 1), 0x0000ff, 140);

        scene.add(xAxis);
        scene.add(zAxis);

        // Create a plane for the image (initially invisible)
        const planeGeometry = new THREE.PlaneGeometry(10, 10);
        const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xeeeeee });
        const imagePlane = new THREE.Mesh(planeGeometry, planeMaterial);
        imagePlane.rotation.x = -Math.PI / 2; // Rotate to lie flat
        imagePlane.visible = false; // Hide until image loads
        scene.add(imagePlane);

        // OrbitControls for interaction
        const controls = new THREE.OrbitControls(activeCamera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.rotateSpeed = 0.4;

        controls.update();

        function setView(camera) {

            controls.reset();

            activeCamera = camera;
            controls.object = camera;
            transformControlss.camera = camera;

            if (camera === cameras.top) {
                camera.position.set(0, 10, 0);
                camera.lookAt(0, 0, 0);
            } else if (camera === cameras.front) {
                camera.position.set(0, 0, 10);
                camera.lookAt(0, 0, 0);
            } else if (camera === cameras.left) {
                camera.position.set(-10, 0, 0);
                camera.lookAt(0, 0, 0);
            }

            // Update projection matrices
            if (camera.isOrthographicCamera) {
                updateOrthoCameras();
            }

            // Toggle wireframe based on view
            const isTopView = (camera === cameras.top);

            // First, clean up any existing wireframe lines from all planes
            planes.forEach(plane => {
                if (plane.mesh.userData.wireframeLine) {
                    scene.remove(plane.mesh.userData.wireframeLine);
                    plane.mesh.userData.wireframeLine = null;
                }
                plane.mesh.visible = true; // Make sure all planes are visible by default
            });

            // If in top view, create new wireframe lines
            if (isTopView) {
                planes.forEach(plane => {
                    // Convert to Line2 for thicker wireframe
                    const geometry = plane.mesh.geometry;
                    const edges = new THREE.EdgesGeometry(geometry);

                    // Create Line2 geometry
                    const positions = [];
                    const attrPos = edges.getAttribute('position');
                    for (let i = 0; i < attrPos.count; i++) {
                        positions.push(attrPos.getX(i), attrPos.getY(i), attrPos.getZ(i));
                    }

                    const lineGeometry = new THREE.LineGeometry();
                    lineGeometry.setPositions(positions);

                    // Create Line2 material with thicker lines
                    const lineMaterial = new THREE.LineMaterial({
                        color: 0xff0000,
                        linewidth: 0.01, // Thicker line width
                        dashed: false
                    });

                    // Create the Line2 object
                    const line = new THREE.Line2(lineGeometry, lineMaterial);
                    line.computeLineDistances();
                    line.scale.set(1, 1, 1);

                    // Store reference to the line so we can remove it later
                    plane.mesh.userData.wireframeLine = line;

                    // Add to scene and hide the original mesh
                    line.position.copy(plane.mesh.position);
                    line.rotation.copy(plane.mesh.rotation);
                    scene.add(line);
                    plane.mesh.visible = false;
                });
            }

            if (camera.isPerspectiveCamera) {
                controls.mouseButtons.LEFT = THREE.MOUSE.ROTATE;
                controls.mouseButtons.RIGHT = THREE.MOUSE.PAN;
                controls.enableRotate = true;
            } else {
                controls.mouseButtons.LEFT = THREE.MOUSE.PAN;
                controls.mouseButtons.RIGHT = THREE.MOUSE.ROTATE;
                controls.enableRotate = false;
            }
            controls.update();
        }
        // setView(activeCamera);

        let scalingcheck = false;
        let aspect = null;

        // 5. Handle image upload
        document.getElementById("imageInput").addEventListener("change", imageupload);

        let targetHeight = 10;

        function imageupload(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Check if file is an image (PNG, JPG, etc.)
            if (!file.type.match("image.*")) {
                alert("Please upload an image file (PNG, JPG, etc.)");
                return;
            }

            const reader = new FileReader();
            reader.onload = function (e) {
                const imageUrl = e.target.result;

                //to read the image dimension 
                const img = new Image();
                img.onload = function () {
                    aspect = img.width / img.height;
                    const targetHeight = 10;
                    const targetWidth = targetHeight * aspect;

                    imagePlane.geometry.dispose();
                    imagePlane.geometry = new THREE.PlaneGeometry(targetWidth, targetHeight);
                }
                const texture = new THREE.TextureLoader().load(imageUrl, function (texture) {
                    // Success: Apply texture to the plane
                    imagePlane.material.map = texture;
                    imagePlane.material.needsUpdate = true;
                    imagePlane.visible = true;
                    grid.visible = true; // Hide grid
                }, undefined, (error) => {
                    console.error("Error loading image:", error);
                    alert("Failed to load image. Try another file.");
                });
                img.src = imageUrl;
            };
            reader.onerror = (error) => {
                console.error("FileReader error:", error);
                alert("Error reading file. Try again.");
            };
            reader.readAsDataURL(file);
        }

        // Array to store all planes
        const planes = [];
        let selectedPlane = null;
        let gui = new dat.GUI();
        gui.domElement.classList.add("my-custom-gui");
        let transformControls = null;

        //new bit for scaling
        let isMeasuring = false;
        let measurePoints = [];

        function handleMeasurementClick(event) {
            if (!isMeasuring) return;

            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, cameras.top);

            // Check intersections with all scene objects (more reliable)
            const intersects = raycaster.intersectObject(imagePlane);
            let distance = null;

            if (intersects.length > 0) {
                const point = intersects[0].point;
                measurePoints.push(point);
                console.log(`Point ${measurePoints.length} recorded at:`, point);

                if (measurePoints.length === 2) {
                    distance = measurePoints[0].distanceTo(measurePoints[1]);
                    console.log(`Distance between points: ${distance.toFixed(2)} units`);

                    cleanupMeasurement();
                }
            }
            return distance;
        }

        function cleanupMeasurement() {
            measurePoints = [];
            isMeasuring = false;
            renderer.domElement.removeEventListener('click', handleMeasurementClick);
        }

        function handleScalingClick(event) {
            scalingdist = handleMeasurementClick(event);
        }

        let scalingdist = null;
        document.getElementById("scalingbutton").addEventListener("click", function () {
            setView(cameras.top);
            isMeasuring = true;
            scalingcheck = true;
            measurePoints = [];
            console.log("Ready to measure - click two points in the scene");

            // Add temporary click listener
            renderer.domElement.removeEventListener('click', handleScalingClick);
            renderer.domElement.addEventListener('click', handleScalingClick);
        });

        document.getElementById("updatescale").addEventListener("click", function () {
            const inputvalue = document.getElementById("scalinginput").value;
            if (!inputvalue) {
                alert("please key in the scale first")
            }
            else {
                updatemeasureplane(inputvalue);
            }
        })

        function updatemeasureplane(input) {
            if (!scalingdist || !aspect) {
                console.error("Measurement data not available");
                return;
            }

            // Calculate scaling factor
            let scalingfactor = input / scalingdist;
            const newtargetHeight = targetHeight * scalingfactor;
            const newtargetWidth = newtargetHeight * aspect;

            targetHeight = newtargetHeight;

            // Preserve current material and visibility
            const currentMaterial = imagePlane.material;
            const currentVisibility = imagePlane.visible;
            const currentPosition = imagePlane.position.clone();
            const currentRotation = imagePlane.rotation.clone();

            // Dispose old geometry and create new one
            imagePlane.geometry.dispose();
            imagePlane.geometry = new THREE.PlaneGeometry(newtargetWidth, newtargetHeight);

            // Restore properties
            imagePlane.material = currentMaterial;
            imagePlane.visible = currentVisibility;
            imagePlane.position.copy(currentPosition);
            imagePlane.rotation.copy(currentRotation);

            console.log("Plane updated with new dimensions:", newtargetWidth, newtargetHeight);
        }
        let nextId = 1;
        function generateId() {
            return nextId++;
        }

        // Function to create a new plane
        function createPlane(width = 1, height = 1) {
            const geometry = new THREE.PlaneGeometry(width, height);
            // Default to Receiver type with yellow color
            const defaultType = "Receiver";
            const defaultColorHex = 0xffff00;
            const material = new THREE.MeshStandardMaterial({
                color: defaultColorHex,
                side: THREE.DoubleSide,
                wireframe: false,
            });

            const plane = new THREE.Mesh(geometry, material);
            plane.position.set(0, 0, 0);
            plane.rotation.y = Math.PI * 2;
            plane.scale.set(1, 1, 1);
            const defaultName = `Plane ${planes.length + 1}`;
            // Store plane data
            const planeData = {
                id: generateId(),
                mesh: plane,
                width: width,
                height: height,
                // Store default values
                defaultWidth: width,
                defaultHeight: height,
                defaultX: 0,
                defaultY: height / 2,
                defaultZ: 0,
                defaultAngle: 0,
                defaultColor: material.color.getHex(),
                name: defaultName,
                x: plane.position.x,
                y: plane.position.y,
                z: plane.position.z,
                angle: plane.rotation.y * 180 / Math.PI,
                incline: plane.rotation.x * 180 / Math.PI,
                color: material.color.getHex(),
                temperature: 0,
                type: defaultType,
                positive: true
            };

            planes.push(planeData);
            scene.add(plane);

            // Make plane selectable
            plane.userData = planeData;
            if (history.length === 0) {
                initializeHistory();
            }
            captureState("Plane created");
            return planeData;

        }

        function resetPlaneToDefault() {
            if (selectedPlanes.length === 0) {
                alert("Please select at least one plane first");
                return;
            }

            captureState("Before reset");

            if (selectedPlaneGroup) {
                ungroupPlanes();
            }

            selectedPlanes.forEach(planeData => {
                // Reset all properties to defaults
                planeData.width = 1;
                planeData.height = 1;
                planeData.x = 0;
                planeData.y = 0.5;
                planeData.z = 0;
                planeData.angle = 0;
                planeData.incline = 0; // Reset incline to 0
                planeData.color = planeData.defaultColor;

                // Update the mesh
                planeData.mesh.geometry.dispose();
                planeData.mesh.geometry = new THREE.PlaneGeometry(
                    planeData.width,
                    planeData.height
                );

                planeData.mesh.position.set(
                    planeData.x,
                    planeData.y,
                    planeData.z
                );
                planeData.mesh.rotation.set(
                    planeData.incline * Math.PI / 180, // x rotation (incline)
                    planeData.angle * Math.PI / 180,   // y rotation (angle)
                    0                                  // z rotation
                );
                planeData.mesh.scale.set(1, 1, 1);
                planeData.mesh.material.color.setHex(planeData.color);
            });

            // Update the GUI
            if (selectedPlanes.length > 0) {
                updateGUI(selectedPlanes[selectedPlanes.length - 1]);
            }

        }

        // Add event listener for the reset button
        document.getElementById("resetPlane").addEventListener("click", resetPlaneToDefault);

        function deleteplanefn() {
            if (selectedPlanes.length === 0) return;

            captureState("Before delete");

            // Delete all selected planes
            selectedPlanes.forEach(planeData => {
                if (transformControlss.object === planeData.mesh) {
                    transformControlss.detach();
                }

                scene.remove(planeData.mesh);

                const index = planes.indexOf(planeData);
                if (index > -1) {
                    planes.splice(index, 1);
                }

                planeData.mesh.geometry.dispose();
                planeData.mesh.material.dispose();
            });

            gui.destroy();
            gui = new dat.GUI();
            selectedPlanes = [];
            captureState();
        }

        document.getElementById("deleteplane").addEventListener("click", deleteplanefn);

        // Function to update GUI for selected plane
        function updateGUI(planeData) {
            gui.destroy();
            gui = new dat.GUI();

            const nameController = gui.add(planeData, 'name').name('Name');
            nameController.onChange(function (newName) {
                const nameExists = planes.some(p => p !== planeData && p.name === newName);
                if (nameExists) {
                    alert('This name already exists! Please choose a different name.');
                    nameController.setValue(planeData.name);
                    return;
                }
                planeData.name = newName;
                captureState();
            });

            // Add controllers with explicit state capture
            const controllers = {
                width: gui.add(planeData, 'width').name('Width').step(0.1),
                height: gui.add(planeData, 'height').name('Height').step(0.1),
                x: gui.add(planeData, 'x').name('X-position').step(0.1),
                y: gui.add(planeData, 'y').name('Y-position').step(0.01),
                z: gui.add(planeData, 'z').name('Z-position').step(0.1),
                angle: gui.add(planeData, 'angle', -180, 180).name('Rotation').step(1),
                incline: gui.add(planeData, 'incline', -180, 180).name("Inclination").step(1),
                temp: gui.add(planeData, "temperature").name("Heat Flux"),
                type: gui.add(planeData, "type", ["Receiver", "Emitter", "Inert"]).name("Type"),
                positive: gui.add(planeData, "positive").name("Receiver X-positive"),
            };

            // Track previous values
            controllers.width.__oldValue = planeData.width;
            controllers.height.__oldValue = planeData.height;

            // Single onChange handler for all properties
            function handleGUIChange() {
                // Handle geometry changes
                if (controllers.width.__oldValue !== planeData.width ||
                    controllers.height.__oldValue !== planeData.height) {

                    planeData.defaultWidth = planeData.width;
                    planeData.defaultHeight = planeData.height;

                    planeData.mesh.geometry.dispose();
                    planeData.mesh.geometry = new THREE.PlaneGeometry(
                        planeData.width,
                        planeData.height
                    );

                    planeData.mesh.scale.set(1, 1, 1);

                    controllers.width.__oldValue = planeData.width;
                    controllers.height.__oldValue = planeData.height;
                }

                // Update position and rotation
                planeData.mesh.position.set(planeData.x, planeData.y, planeData.z);
                planeData.mesh.rotation.set(
                    planeData.incline * Math.PI / 180,
                    planeData.angle * Math.PI / 180,
                    0
                );

                // Ensure temperature control reflects current type
                updateTemperatureControl();

                // Always capture state after any change
                captureState();
            }

            // Add listeners to all controllers
            Object.values(controllers).forEach(controller => {
                if (controller.onChange) {
                    controller.onChange(handleGUIChange);
                }
            });

            // Helper to enable/disable a GUI controller input element
            function setControllerDisabled(controller, disabled) {
                if (!controller || !controller.domElement) return;
                const inputEl = controller.domElement.querySelector('input');
                if (inputEl) inputEl.disabled = disabled;
            }

            // Enable temp only for Emitters; otherwise set to 0 and disable
            function updateTemperatureControl() {
                const isEmitter = String(planeData.type || '').toLowerCase() === 'emitter';
                if (!isEmitter) {
                    if (planeData.temperature !== 0) {
                        planeData.temperature = 0;
                        controllers.temp.updateDisplay();
                        // Capture only when value actually changed
                        captureState();
                    }
                    setControllerDisabled(controllers.temp, true);
                } else {
                    setControllerDisabled(controllers.temp, false);
                }
            }

            // Update color by type, preserving selection highlight
            function updateColorByType() {
                const typeLower = String(planeData.type || '').toLowerCase();
                let hex = 0xffff00; // receiver default (yellow)
                if (typeLower === 'emitter') {
                    hex = 0xff0000; // emitter red
                } else if (typeLower === 'inert') {
                    hex = 0x0000ff; // inert blue
                }
                planeData.color = hex;
                // If currently selected, keep highlight (yellow), otherwise set mapped color
                planeData.mesh.material.color.setHex(selectedPlanes.includes(planeData) ? 0xe3e3e3 : hex);
            }

            // React immediately to Type changes
            controllers.type.onChange(function () {
                updateTemperatureControl();
                updateColorByType();
                captureState();
            });

            // Initialize temperature control state on GUI creation
            updateTemperatureControl();
            updateColorByType();
        }


        renderer.domElement.addEventListener('click', (event) => {
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, activeCamera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            // Clear previous group if not holding shift and clicking empty space
            if (!isShiftPressed && selectedPlaneGroup && intersects.length === 0) {
                ungroupPlanes();
                return;
            }

            for (let i = 0; i < intersects.length; i++) {
                const object = intersects[i].object;

                // Find the plane data (might be a child of the group)
                let planeData = null;
                if (object.userData && planes.some(p => p.mesh === object)) {
                    planeData = object.userData;
                } else if (object.parent && object.parent.userData && planes.some(p => p.mesh === object.parent)) {
                    planeData = object.parent.userData;
                }

                if (planeData) {
                    if (isShiftPressed) {
                        // Shift+click - toggle selection
                        const index = selectedPlanes.indexOf(planeData);
                        if (index === -1) {
                            // Add to selection
                            selectedPlanes.push(planeData);
                            planeData.mesh.material.color.setHex(0xe3e3e3);

                            // If we have multiple planes selected, create/update group
                            if (selectedPlanes.length > 1) {
                                createOrUpdateGroup();
                            }
                        } else {
                            // Remove from selection
                            selectedPlanes.splice(index, 1);
                            planeData.mesh.material.color.setHex(planeData.color);

                            // If the plane is in a group, restore its parent and position
                            if (selectedPlaneGroup && planeData.mesh.parent === selectedPlaneGroup) {
                                const original = originalPositions.get(planeData);
                                selectedPlaneGroup.remove(planeData.mesh);
                                if (original) {
                                    original.parent.add(planeData.mesh);
                                    planeData.mesh.position.copy(original.worldPosition);
                                }
                                planeData.mesh.visible = true;
                            }

                            // Update group if we still have multiple planes
                            if (selectedPlanes.length > 1) {
                                createOrUpdateGroup();
                            } else {
                                // If only one plane left, disband group and restore visibility for all
                                ungroupPlanes();
                                planes.forEach(p => p.mesh.visible = true);
                            }
                        }
                    } else {
                        // Regular click - single selection
                        // Check if this plane is already the only selected plane
                        if (selectedPlanes.length === 1 && selectedPlanes[0] === planeData) {
                            // If clicking on the only selected plane, deselect it
                            selectedPlanes = [];
                            planeData.mesh.material.color.setHex(planeData.color);
                            ungroupPlanes();
                        } else {
                            // Otherwise, select this plane as the only selection
                            ungroupPlanes();
                            planes.forEach(p => p.mesh.material.color.setHex(p.color));
                            planes.forEach(p => p.mesh.visible = true);
                            selectedPlanes = [planeData];
                            planeData.mesh.material.color.setHex(0xe3e3e3);
                        }
                    }

                    // Update transform controls
                    updateTransformControls();
                    return;
                }
            }

            // Clicked on empty space without shift - clear selection
            if (!isShiftPressed) {
                ungroupPlanes();
                planes.forEach(p => p.mesh.material.color.setHex(p.color));
                selectedPlanes = [];
                transformControlss.detach();
                gui.destroy();
                gui = new dat.GUI();
            }
        });

        function updateTransformControls() {
            if (selectedPlanes.length === 0) {
                transformControlss.detach();
                gui.destroy();
                gui = new dat.GUI();
            } else if (selectedPlaneGroup) {
                // Control the group if we have one
                transformControlss.attach(selectedPlaneGroup);
                updateGUI(selectedPlanes[selectedPlanes.length - 1]);
            } else {
                // Control the last selected plane
                transformControlss.attach(selectedPlanes[selectedPlanes.length - 1].mesh);
                updateGUI(selectedPlanes[selectedPlanes.length - 1]);
            }
        }
        function createOrUpdateGroup() {
            // If no group exists, create one
            if (!selectedPlaneGroup) {
                selectedPlaneGroup = new THREE.Group();
                scene.add(selectedPlaneGroup);

                // Store original positions and parents
                originalPositions = new Map();
                selectedPlanes.forEach(plane => {
                    // Store the world position and original parent
                    const worldPos = plane.mesh.getWorldPosition(new THREE.Vector3());
                    originalPositions.set(plane, {
                        worldPosition: worldPos.clone(),
                        parent: plane.mesh.parent
                    });

                    // Calculate local position relative to group center
                    const center = calculateGroupCenter();
                    plane.mesh.position.copy(worldPos).sub(center);

                    // Add to group
                    selectedPlaneGroup.add(plane.mesh);
                });

                // Position group at center
                const center = calculateGroupCenter();
                selectedPlaneGroup.position.copy(center);
            } else {
                // For existing group, just add any new planes
                selectedPlanes.forEach(plane => {
                    if (plane.mesh.parent !== selectedPlaneGroup) {
                        const worldPos = plane.mesh.getWorldPosition(new THREE.Vector3());
                        originalPositions.set(plane, {
                            worldPosition: worldPos.clone(),
                            parent: plane.mesh.parent
                        });

                        const center = selectedPlaneGroup.position;
                        plane.mesh.position.copy(worldPos).sub(center);
                        selectedPlaneGroup.add(plane.mesh);
                    }
                });
            }
            // Don't capture state when creating/updating groups - only capture when the group is actually transformed
        }

        function calculateGroupCenter() {
            const center = new THREE.Vector3();
            selectedPlanes.forEach(plane => {
                if (originalPositions.has(plane)) {
                    center.add(originalPositions.get(plane).worldPosition);
                } else {
                    center.add(plane.mesh.getWorldPosition(new THREE.Vector3()));
                }
            });
            center.divideScalar(selectedPlanes.length);
            return center;
        }

        function ungroupPlanes() {
            if (!selectedPlaneGroup) return;

            // Restore planes to their original positions and parents
            selectedPlanes.forEach(plane => {
                const original = originalPositions.get(plane);
                if (original) {
                    // Remove from group first
                    selectedPlaneGroup.remove(plane.mesh);

                    // Add back to original parent (usually the scene)
                    original.parent.add(plane.mesh);

                    // Restore world position
                    plane.mesh.position.copy(original.worldPosition);

                    // Update plane data to match world position
                    plane.x = plane.mesh.position.x;
                    plane.y = plane.mesh.position.y;
                    plane.z = plane.mesh.position.z;
                }
            });

            // Clean up the group
            scene.remove(selectedPlaneGroup);
            selectedPlaneGroup = null;
            originalPositions.clear();

            // Update GUI to reflect changes
            if (selectedPlanes.length > 0) {
                updateGUI(selectedPlanes[selectedPlanes.length - 1]);
            }
            // Don't capture state when ungrouping - the visual state doesn't change
        }


        // Dragging variables
        let isDragging = false;
        let activeAxis = null;
        let dragPlane = new THREE.Plane();
        let dragOffset = new THREE.Vector3();
        let state_control = false;
        const raycaster1 = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        let transformControlss = null;

        // Initialize transform controls
        function initTransformControls() {
            transformControlss = new THREE.TransformControls(activeCamera, renderer.domElement);
            transformControlss.setSpace('local');
            transformControlss.setMode('translate');
            transformControlss.size = 0.5;
            transformControlss.setTranslationSnap(0.01);  // Snap translation to 0.1 units
            transformControlss.setRotationSnap(Math.PI / 180); // Snap rotation to 10 degrees
            transformControlss.setScaleSnap(0.1); // Snap scaling to 0.05 units (5% increments)

            transformControlss.showX = true;
            transformControlss.showY = true;
            transformControlss.showZ = true;
            scene.add(transformControlss);

            // Disable orbit controls when transforming
            transformControlss.addEventListener('dragging-changed', function (event) {
                controls.enabled = !event.value;
                // When dragging starts, record the group's start position
                if (event.value && selectedPlaneGroup && transformControlss.object === selectedPlaneGroup) {
                    groupDragStartPosition = selectedPlaneGroup.position.clone();
                }
                // When dragging ends (event.value === false)
                if (!event.value) {
                    if (selectedPlaneGroup && transformControlss.object === selectedPlaneGroup) {
                        // Commit the group transformation to individual planes
                        commitGroupTransform();
                    } else {
                        // Capture state for individual plane transformations
                        captureState("Transform drag ended");
                    }
                }
            });

            transformControlss.addEventListener('objectChange', function () {
                if (selectedPlaneGroup && transformControlss.object === selectedPlaneGroup) {
                    // Update all planes when group moves
                    selectedPlanes.forEach(plane => {
                        plane.x = plane.mesh.position.x + selectedPlaneGroup.position.x;
                        plane.y = plane.mesh.position.y + selectedPlaneGroup.position.y;
                        plane.z = plane.mesh.position.z + selectedPlaneGroup.position.z;
                    });
                } else if (selectedPlanes.length > 0 &&
                    transformControlss.object === selectedPlanes[selectedPlanes.length - 1].mesh) {
                    updatePlaneDataFromTransform();
                }
                if (selectedPlanes.length > 0) {
                    updateGUI(selectedPlanes[selectedPlanes.length - 1]);
                }
            });
        }

        function commitGroupTransform() {
            if (!selectedPlaneGroup || selectedPlanes.length === 0) return;

            // Calculate the total transformation
            const groupPosition = selectedPlaneGroup.position.clone();

            // Update each plane's world position
            selectedPlanes.forEach(plane => {
                // Calculate new world position
                const newWorldPos = new THREE.Vector3().addVectors(
                    plane.mesh.position,
                    groupPosition
                );

                // Update plane data
                plane.x = newWorldPos.x;
                plane.y = newWorldPos.y;
                plane.z = newWorldPos.z;

                // Update original positions (for future grouping)
                if (originalPositions.has(plane)) {
                    originalPositions.get(plane).worldPosition.copy(newWorldPos);
                }
            });

            // Reset group position to origin
            selectedPlaneGroup.position.set(0, 0, 0);

            // Update plane positions relative to the group (now at origin)
            selectedPlanes.forEach(plane => {
                plane.mesh.position.set(plane.x, plane.y, plane.z);
            });

            // Re-center the group
            updateGroupPosition();

            // Only capture state if the group was actually moved
            if (groupDragStartPosition && !groupDragStartPosition.equals(groupPosition)) {
                captureState();
            }
            groupDragStartPosition = null;
        }

        function updateGroupPosition() {
            if (!selectedPlaneGroup || selectedPlanes.length < 2) return;

            // Calculate center point in world space
            const center = new THREE.Vector3();
            selectedPlanes.forEach(plane => {
                if (originalPositions.has(plane)) {
                    center.add(originalPositions.get(plane).worldPosition);
                } else {
                    center.add(new THREE.Vector3(plane.x, plane.y, plane.z));
                }
            });
            center.divideScalar(selectedPlanes.length);

            // Update group position
            selectedPlaneGroup.position.copy(center);

            // Update plane positions relative to group
            selectedPlanes.forEach(plane => {
                const worldPos = originalPositions.has(plane) ?
                    originalPositions.get(plane).worldPosition.clone() :
                    new THREE.Vector3(plane.x, plane.y, plane.z);

                plane.mesh.position.copy(worldPos).sub(center);
            });
        }

        function updatePlaneDataFromTransform() {
            if (selectedPlanes.length === 0) return;

            const planeData = selectedPlanes[selectedPlanes.length - 1];
            const mesh = planeData.mesh;

            // Update position
            planeData.x = planeData.mesh.position.x;
            planeData.y = planeData.mesh.position.y;
            planeData.z = planeData.mesh.position.z;

            // Update rotation (convert to degrees)
            planeData.angle = Math.abs(mesh.rotation.y * (180 / Math.PI)) < 1e-10 ? 0 : mesh.rotation.y * (180 / Math.PI);
            planeData.incline = Math.abs(mesh.rotation.x * (180 / Math.PI)) < 1e-10 ? 0 : mesh.rotation.x * (180 / Math.PI);

            if (transformControlss.getMode() === 'scale') {
                planeData.width = planeData.defaultWidth * mesh.scale.x;
                planeData.height = planeData.defaultHeight * mesh.scale.y;
            }

            // Update the GUI to reflect changes
            updateGUI(planeData);
        }

        // Call this after setting up your scene
        initTransformControls();

        function restoration() {
            if (state_control) {
                controls.enabled = true;
                controls.update();
                state_control = false;
            }
        }
        window.addEventListener("mousedown", restoration);
        window.addEventListener('keydown', (event) => {
            if (!transformControlss) return;

            switch (event.key.toLowerCase()) {
                case 'w': // Translate
                    transformControlss.setMode('translate');
                    transformControlss.showZ = true;
                    break;
                case 'e': // Scale
                    transformControlss.setMode('scale');
                    transformControlss.showZ = true;
                    break;
                case 'r': // Rotate
                    transformControlss.setMode('rotate');
                    transformControlss.showZ = false;
                    break;
            }
        });
        window.addEventListener("keydown", function (event) {
            if (event.key === "Delete") {
                deleteplanefn();
            }
        })

        // Add plane button
        const addplanebtn = document.getElementById("addplane");
        addplanebtn.addEventListener("click", function () {
            const newPlane = createPlane();
            updateGUI(newPlane);
            selectedPlane = newPlane;
            transformControlss.attach(newPlane.mesh);
        });


        // Export function
        document.getElementById('exportBtn').addEventListener('click', exportScene);

        function exportScene() {
            const sceneData = {
                version: '1.0',
                imagePlane: {
                    visible: imagePlane.visible,
                    position: imagePlane.position.toArray(),
                    rotation: imagePlane.rotation.toArray(),
                    scale: imagePlane.scale.toArray(),
                    geometry: {
                        width: imagePlane.geometry.parameters.width,
                        height: imagePlane.geometry.parameters.height
                    },
                    texture: imagePlane.material.map ? imagePlane.material.map.image.currentSrc : null
                },
                planes: planes.map(plane => ({
                    name: plane.name,
                    position: plane.mesh.position.toArray(),
                    rotation: plane.mesh.rotation.toArray(),
                    scale: [1, 1, 1],
                    width: plane.width,
                    height: plane.height,
                    color: plane.color,
                    temperature: plane.temperature,
                    type: plane.type,
                    // Include default values for proper import
                    defaultWidth: plane.defaultWidth,
                    defaultHeight: plane.defaultHeight,
                    // Include derived properties
                    x: plane.x,
                    y: plane.y,
                    z: plane.z,
                    angle: plane.angle,
                    incline: plane.incline
                })),
                scalingFactor: scalingdist ? {
                    measuredDistance: scalingDistance,
                    inputValue: document.getElementById('scalinginput').value
                } : null
            };

            const blob = new Blob([JSON.stringify(sceneData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = 'scene_export.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Import function
        // document.getElementById('importBtn').addEventListener('click', () => {
        //     document.getElementById('importFile').click();
        // });

        document.getElementById('importFile').addEventListener('change', importScene);

        function importScene(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const sceneData = JSON.parse(e.target.result);
                    loadSceneData(sceneData);
                } catch (error) {
                    console.error('Error parsing scene file:', error);
                    alert('Error loading scene file');
                }
            };
            reader.readAsText(file);
        }

        async function loadSceneData(sceneData) {
            // Clear existing scene
            while (planes.length) {
                deleteplanefn();
            }

            // Load image plane
            if (sceneData.imagePlane.texture) {
                await loadImageTexture(sceneData.imagePlane.texture);

                imagePlane.position.fromArray(sceneData.imagePlane.position);
                imagePlane.rotation.fromArray(sceneData.imagePlane.rotation);
                imagePlane.scale.fromArray(sceneData.imagePlane.scale);
                imagePlane.visible = sceneData.imagePlane.visible;

                // Update geometry
                imagePlane.geometry.dispose();
                imagePlane.geometry = new THREE.PlaneGeometry(
                    sceneData.imagePlane.geometry.width,
                    sceneData.imagePlane.geometry.height
                );
            }

            // Load planes
            sceneData.planes.forEach(planeData => {
                const newPlane = createPlane(planeData.width, planeData.height);
                newPlane.name = planeData.name || `Plane ${planes.length}`;

                // Update the default dimensions to match the imported dimensions
                newPlane.defaultWidth = planeData.width;
                newPlane.defaultHeight = planeData.height;

                // Set position and rotation
                newPlane.mesh.position.fromArray(planeData.position);
                newPlane.mesh.rotation.fromArray(planeData.rotation);

                // Handle scale properly - if scale is not 1,1,1, we need to adjust the actual dimensions
                if (planeData.scale && (planeData.scale[0] !== 1 || planeData.scale[1] !== 1)) {
                    // If there's a scale, apply it to the dimensions
                    newPlane.width = planeData.width * planeData.scale[0];
                    newPlane.height = planeData.height * planeData.scale[1];
                    // Reset scale to 1,1,1 since we've incorporated it into dimensions
                    newPlane.mesh.scale.set(1, 1, 1);
                } else {
                    // No scale or scale is 1,1,1, just use the imported dimensions
                    newPlane.width = planeData.width;
                    newPlane.height = planeData.height;
                    newPlane.mesh.scale.set(1, 1, 1);
                }

                // Update the mesh geometry to match the new dimensions
                newPlane.mesh.geometry.dispose();
                newPlane.mesh.geometry = new THREE.PlaneGeometry(newPlane.width, newPlane.height);

                // Set color and temperature
                newPlane.color = planeData.color;
                newPlane.mesh.material.color.setHex(planeData.color);
                if (planeData.temperature !== undefined) {
                    newPlane.temperature = planeData.temperature;
                }
                if (planeData.type !== undefined) {
                    newPlane.type = planeData.type;
                }
                if (planeData.positive !== undefined) {
                    newPlane.positive = planeData.positive;
                } else {
                    newPlane.positive = true; // Default to true for backward compatibility
                }
                // Update derived properties - use imported values if available, otherwise calculate from mesh
                if (planeData.x !== undefined) {
                    newPlane.x = planeData.x;
                } else {
                    newPlane.x = newPlane.mesh.position.x;
                }
                if (planeData.y !== undefined) {
                    newPlane.y = planeData.y;
                } else {
                    newPlane.y = newPlane.mesh.position.y;
                }
                if (planeData.z !== undefined) {
                    newPlane.z = planeData.z;
                } else {
                    newPlane.z = newPlane.mesh.position.z;
                }
                if (planeData.angle !== undefined) {
                    newPlane.angle = planeData.angle;
                } else {
                    newPlane.angle = newPlane.mesh.rotation.y * (180 / Math.PI);
                }
                if (planeData.incline !== undefined) {
                    newPlane.incline = planeData.incline;
                } else {
                    newPlane.incline = newPlane.mesh.rotation.x * (180 / Math.PI);
                }

                updateGUI(newPlane);

                // Force a geometry update to ensure the mesh size matches the stored dimensions
                if (newPlane.mesh.geometry) {
                    newPlane.mesh.geometry.dispose();
                }
                newPlane.mesh.geometry = new THREE.PlaneGeometry(newPlane.width, newPlane.height);

                // Debug logging
                console.log(`Imported plane "${newPlane.name}":`, {
                    width: newPlane.width,
                    height: newPlane.height,
                    defaultWidth: newPlane.defaultWidth,
                    defaultHeight: newPlane.defaultHeight,
                    scale: newPlane.mesh.scale.toArray(),
                    position: newPlane.mesh.position.toArray(),
                    geometry: {
                        width: newPlane.mesh.geometry.parameters.width,
                        height: newPlane.mesh.geometry.parameters.height
                    }
                });
            });

            // Load scaling data
            if (sceneData.scalingFactor) {
                scalingDistance = sceneData.scalingFactor.measuredDistance;
                document.getElementById('scalinginput').value = sceneData.scalingFactor.inputValue;
            }

            // Validate and fix any scaling issues
            planes.forEach(plane => {
                // Ensure the mesh geometry matches the stored dimensions
                const expectedWidth = plane.width;
                const expectedHeight = plane.height;
                const actualWidth = plane.mesh.geometry.parameters.width;
                const actualHeight = plane.mesh.geometry.parameters.height;

                if (Math.abs(expectedWidth - actualWidth) > 0.001 || Math.abs(expectedHeight - actualHeight) > 0.001) {
                    console.warn(`Fixing size mismatch for plane "${plane.name}":`, {
                        expected: { width: expectedWidth, height: expectedHeight },
                        actual: { width: actualWidth, height: actualHeight }
                    });

                    // Recreate geometry with correct dimensions
                    plane.mesh.geometry.dispose();
                    plane.mesh.geometry = new THREE.PlaneGeometry(expectedWidth, expectedHeight);

                    // Reset scale to 1,1,1
                    plane.mesh.scale.set(1, 1, 1);
                }
            });

            alert('Scene imported successfully!');
        }

        async function loadImageTexture(imageUrl) {
            return new Promise((resolve, reject) => {
                const textureLoader = new THREE.TextureLoader();
                textureLoader.load(imageUrl,
                    (texture) => {
                        imagePlane.material.map = texture;
                        imagePlane.material.needsUpdate = true;
                        imagePlane.visible = true;

                        // Update aspect ratio
                        const img = new Image();
                        img.onload = function () {
                            aspect = img.width / img.height;
                            resolve();
                        };
                        img.src = imageUrl;
                    },
                    undefined,
                    (error) => {
                        console.error('Error loading image:', error);
                        reject(error);
                    }
                );
            });
        }

        let dataarrayforcontour = null;
        // Receiver grid size (N x N), default 10
        let receiverGridSize = 10;
        // Backend endpoint for contour generation
        const BACKEND_CONTOUR_URL = '/api/contour';

        // Generate smoother, more realistic fields for contours
        // Removed random generators; contours now rely on backend-provided data only

        // Holder for backend-provided contour data
        let uploadedContour = null; // { width, height, values }

        // Normalize various JSON formats into {width,height,values(flat array)}
        function normalizeContourJson(json) {
            // If already normalized
            if (json && Number.isInteger(json.width) && Number.isInteger(json.height) && Array.isArray(json.values)) {
                // If values are 2D, flatten
                if (Array.isArray(json.values[0])) {
                    const flat = [];
                    for (let y = 0; y < json.height; y++) {
                        for (let x = 0; x < json.width; x++) {
                            flat.push(json.values[y][x]);
                        }
                    }
                    return { width: json.width, height: json.height, values: flat };
                }
                return { width: json.width, height: json.height, values: json.values };
            }
            // If just a 2D array
            if (Array.isArray(json) && Array.isArray(json[0])) {
                const height = json.length;
                const width = json[0].length;
                const flat = [];
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) flat.push(json[y][x]);
                }
                return { width, height, values: flat };
            }
            // If just flat array, require square-ish detection is not reliable; reject
            throw new Error('Unsupported contour JSON format. Expected {width,height,values}, 2D array, or flat array with dims.');
        }

        // Note: uploadedContour should be set by backend integration code before invoking contour rendering

        function generateRbfField(n, m, options = {}) {
            const numSources = options.numSources || 5;
            const amplitudeMin = options.amplitudeMin ?? 2;
            const amplitudeMax = options.amplitudeMax ?? 10;
            const diag = Math.sqrt(n * n + m * m);
            const sigmaMin = options.sigmaMin ?? diag * 0.10;
            const sigmaMax = options.sigmaMax ?? diag * 0.35;
            const gradientStrength = options.gradientStrength ?? 0.15; // 0..1 small trend
            const noiseStd = options.noiseStd ?? 0.03; // relative to max amplitude

            const sources = [];
            for (let i = 0; i < numSources; i++) {
                sources.push({
                    cx: Math.random() * (n - 1),
                    cy: Math.random() * (m - 1),
                    amp: amplitudeMin + Math.random() * (amplitudeMax - amplitudeMin),
                    sigma: sigmaMin + Math.random() * (sigmaMax - sigmaMin)
                });
            }

            const values = new Array(n * m);
            let minV = Infinity, maxV = -Infinity;
            for (let y = 0; y < m; y++) {
                for (let x = 0; x < n; x++) {
                    let v = 0;
                    for (let k = 0; k < sources.length; k++) {
                        const dx = x - sources[k].cx;
                        const dy = y - sources[k].cy;
                        const r2 = dx * dx + dy * dy;
                        const sigma2 = 2 * sources[k].sigma * sources[k].sigma;
                        v += sources[k].amp * Math.exp(-r2 / sigma2);
                    }
                    // Add a gentle gradient/trend to avoid overly symmetric blobs
                    v += gradientStrength * (x / n * amplitudeMax * 0.5 + y / m * amplitudeMax * 0.5);
                    // Add a tiny amount of noise for texture
                    v += (Math.random() * 2 - 1) * noiseStd * amplitudeMax;
                    values[y * n + x] = v;
                    if (v < minV) minV = v;
                    if (v > maxV) maxV = v;
                }
            }
            // Normalize to a friendly range (e.g., 0..10)
            const range = maxV - minV || 1;
            for (let i = 0; i < values.length; i++) {
                values[i] = 10 * (values[i] - minV) / range;
            }
            return values;
        }

        function generateSinusoidalField(n, m, options = {}) {
            const A1 = options.A1 ?? 3, A2 = options.A2 ?? 2.5, A3 = options.A3 ?? 2;
            const fx1 = options.fx1 ?? (2 * Math.PI / (n * 0.9));
            const fy1 = options.fy1 ?? (2 * Math.PI / (m * 0.7));
            const fx2 = options.fx2 ?? (2 * Math.PI / (n * 0.35));
            const fy2 = options.fy2 ?? (2 * Math.PI / (m * 0.5));
            const p1 = options.p1 ?? Math.random() * Math.PI * 2;
            const p2 = options.p2 ?? Math.random() * Math.PI * 2;
            const p3 = options.p3 ?? Math.random() * Math.PI * 2;
            const baseline = options.baseline ?? 2.5;
            const noiseStd = options.noiseStd ?? 0.05;

            const values = new Array(n * m);
            let minV = Infinity, maxV = -Infinity;
            for (let y = 0; y < m; y++) {
                for (let x = 0; x < n; x++) {
                    let v = baseline
                        + A1 * Math.sin(fx1 * x + p1)
                        + A2 * Math.cos(fy1 * y + p2)
                        + A3 * Math.sin(fx2 * x + fy2 * y + p3)
                        + (Math.random() * 2 - 1) * noiseStd;
                    values[y * n + x] = v;
                    if (v < minV) minV = v;
                    if (v > maxV) maxV = v;
                }
            }
            const range = maxV - minV || 1;
            for (let i = 0; i < values.length; i++) {
                values[i] = 10 * (values[i] - minV) / range;
            }
            return values;
        }

        function generatePointsOnPlane(plane, rows = 11, cols = 11) {
            const points = [];
            const width = plane.width;
            const height = plane.height;

            // Calculate step sizes
            const xStep = width / (cols - 1);
            const zStep = height / (rows - 1);

            // Create rotation matrix from plane's rotation and inclination
            const makeHorizontal = new THREE.Matrix4().makeRotationX(-Math.PI / 2);
            const rotationY = new THREE.Matrix4().makeRotationY(plane.angle * Math.PI / 180);
            const rotationX = new THREE.Matrix4().makeRotationX(plane.incline * Math.PI / 180);
            const rotationMatrix = new THREE.Matrix4()
                .multiply(makeHorizontal)
                .multiply(rotationX)
                .multiply(rotationY);

            // Generate grid points
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    // Calculate local position (centered)
                    const xLocal = (col * xStep) - (width / 2);
                    const zLocal = (row * zStep) - (height / 2);
                    const yLocal = 0; // On the plane surface

                    // Create vector and apply rotation
                    const point = new THREE.Vector3(xLocal, yLocal, zLocal);
                    point.applyMatrix4(rotationMatrix);

                    // Add plane position offset
                    point.x += plane.x;
                    point.y += plane.y;
                    point.z += plane.z;

                    points.push({
                        id: row * cols + col + 1,
                        position: {
                            x: parseFloat(point.x.toFixed(4)),
                            y: parseFloat(point.y.toFixed(4)),
                            z: parseFloat(point.z.toFixed(4))
                        },
                        localGrid: {
                            row: row + 1,
                            column: col + 1
                        }
                    });
                }
            }

            return points;
        }

        async function Pointsinfo() {
            const receiver_planes = {};
            const polygons = [];
            const inert_polygons = [];

            // Helpers
            function computeWorldCorners(plane) {
                const width = plane.width;
                const height = plane.height;
                const corners = [
                    new THREE.Vector3(-width/2, 0, -height/2),
                    new THREE.Vector3(width/2, 0, -height/2),
                    new THREE.Vector3(width/2, 0, height/2),
                    new THREE.Vector3(-width/2, 0, height/2)
                ];
                        const makeHorizontal = new THREE.Matrix4().makeRotationX(-Math.PI / 2);
                        const rotationY = new THREE.Matrix4().makeRotationY(plane.angle * Math.PI / 180);
                        const rotationX = new THREE.Matrix4().makeRotationX(plane.incline * Math.PI / 180);
                        const rotationMatrix = new THREE.Matrix4()
                            .multiply(makeHorizontal)
                            .multiply(rotationX)
                            .multiply(rotationY);
                return corners.map(corner => {
                    corner.applyMatrix4(rotationMatrix);
                    corner.add(new THREE.Vector3(plane.x, plane.y, plane.z));
                    return [
                        Math.round(corner.x * 100) / 100,
                        Math.round(corner.y * 100) / 100,
                        Math.round(corner.z * 100) / 100
                    ];
                });
            }

            function computePlaneNormal(plane) {
                const normal = new THREE.Vector3(0, 1, 0);
                const makeHorizontal = new THREE.Matrix4().makeRotationX(-Math.PI / 2);
                const rotationY = new THREE.Matrix4().makeRotationY(plane.angle * Math.PI / 180);
                const rotationX = new THREE.Matrix4().makeRotationX(plane.incline * Math.PI / 180);
                const rotationMatrix = new THREE.Matrix4()
                    .multiply(makeHorizontal)
                    .multiply(rotationX)
                    .multiply(rotationY);
                        normal.applyMatrix4(rotationMatrix);
                // Enforce positive/negative based on plane.positive
                            const absX = Math.abs(normal.x);
                            const absY = Math.abs(normal.y);
                            const absZ = Math.abs(normal.z);
                const dominant = absX >= absY && absX >= absZ ? 'x' : (absY >= absX && absY >= absZ ? 'y' : 'z');
                if (plane.positive) {
                    if ((dominant === 'x' && normal.x < 0) || (dominant === 'y' && normal.y < 0) || (dominant === 'z' && normal.z < 0)) {
                                    normal.negate();
                                }
                            } else {
                    if ((dominant === 'x' && normal.x > 0) || (dominant === 'y' && normal.y > 0) || (dominant === 'z' && normal.z > 0)) {
                                    normal.negate();
                                }
                            }
                return [
                                    Math.round(normal.x * 100) / 100,
                                    Math.round(normal.y * 100) / 100,
                                    Math.round(normal.z * 100) / 100
                ];
            }

            // Build structure
            let receiverPlaneIndex = 1;
            planes.forEach(plane => {
                if (plane.type === "Receiver") {
                    // Calculate grid dimensions based on plane size and user input N
                    const N = Math.max(1, Math.min(50, parseInt(receiverGridSize, 10) || 10));
                    const roundedWidth = Math.ceil(plane.width);
                    const roundedHeight = Math.ceil(plane.height);
                    const gridWidth = roundedWidth * N;
                    const gridHeight = roundedHeight * N;
                    
                    console.log(`Receiver plane ${receiverPlaneIndex}: original size ${plane.width}x${plane.height}, rounded to ${roundedWidth}x${roundedHeight}, grid size ${gridWidth}x${gridHeight}`);
                    
                    const points = generatePointsOnPlane(plane, gridHeight, gridWidth);
                    const normalArr = computePlaneNormal(plane);
                    
                    receiver_planes[`plane${receiverPlaneIndex}`] = {
                        width: gridWidth,
                        height: gridHeight,
                        points: points.map(pt => ({
                            origin: [
                                Math.round(pt.position.x * 100) / 100,
                                Math.round(pt.position.y * 100) / 100,
                                Math.round(pt.position.z * 100) / 100
                            ],
                            normal: normalArr
                        }))
                    };
                    receiverPlaneIndex++;
                } else if (plane.type === "Emitter") {
                    const worldCorners = computeWorldCorners(plane);
                    polygons.push({ polygon: worldCorners, temperature: plane.temperature });
                } else if (plane.type === "Inert") {
                    const worldCorners = computeWorldCorners(plane);
                    inert_polygons.push(worldCorners);
                }
            });

            const exportData = {
                receiver_planes: receiver_planes,
                polygons: polygons,
                inert_polygons: inert_polygons,
                num_rays: 100000
            };

            // Log the output JSON structure
            console.log("Output JSON structure:", JSON.stringify(exportData, null, 2));

            // Send to backend and await contour response
            try {
                const resp = await fetch(BACKEND_CONTOUR_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(exportData)
                });
                if (!resp.ok) throw new Error(`Backend error: ${resp.status}`);
                const contourJson = await resp.json();
                const norm = normalizeContourJson(contourJson);
                uploadedContour = norm;
                dataarrayforcontour = norm.values;
                // Show the contour modal using the received data
                showContourToSelectedPlane();
            } catch (err) {
                console.error('Failed to fetch contour data:', err);
                alert('Failed to fetch contour data from backend.');
            }
        }

        document.getElementById("calculate").addEventListener("click", Pointsinfo);
        // Update receiver grid size from input
        const gridSizeEl = document.getElementById('gridSizeInput');
        if (gridSizeEl) {
            gridSizeEl.addEventListener('change', function () {
                const val = parseInt(this.value, 10);
                if (isNaN(val)) return;
                receiverGridSize = Math.max(1, Math.min(50, val));
            });
        }

        // Add this function to handle the contour generation
        // Removed addContourToSelectedPlane; use backend-provided data via detail modal

        let clipboard = null; // Will store copied planes
        let isCtrlPressed = false; // Track Ctrl key state
        // Add these near your other key listeners
        window.addEventListener('keydown', (event) => {
            if (event.key === 'Control') {
                isCtrlPressed = true;
            }
            // Add copy/paste shortcuts (Ctrl+C, Ctrl+V)
            if (isCtrlPressed && event.key === 'c') {
                copySelected();
            }
            if (isCtrlPressed && event.key === 'v') {
                pasteFromClipboard();
            }
        });

        window.addEventListener('keyup', (event) => {
            if (event.key === 'Control') {
                isCtrlPressed = false;
            }
        });

        function copySelected() {
            if (selectedPlanes.length === 0) return;

            clipboard = {
                isGroup: selectedPlaneGroup !== null,
                planes: selectedPlanes.map(plane => ({
                    width: plane.defaultWidth,
                    height: plane.defaultHeight,
                    position: plane.mesh.position.clone(),
                    rotation: plane.mesh.rotation.clone(),
                    scale: plane.mesh.scale.clone(),
                    color: plane.color,
                    temperature: plane.temperature,
                    type: plane.type,
                    positive: plane.positive
                })),
                relativePositions: selectedPlaneGroup ?
                    selectedPlanes.map(plane => plane.mesh.position.clone()) :
                    null
            };
            console.log('Copied selection to clipboard');
            captureState();
        }


        function pasteFromClipboard() {
            if (!clipboard) return;

            captureState("Before paste");

            // Clear current selection
            planes.forEach(p => p.mesh.material.color.setHex(p.color));
            selectedPlanes = [];
            if (selectedPlaneGroup) {
                ungroupPlanes();
            }

            // Create new planes from clipboard
            const newPlanes = [];
            const offset = new THREE.Vector3(1, 0, 1); // Small offset for pasted copies

            clipboard.planes.forEach((planeData, index) => {
                const newPlane = createPlane(planeData.width, planeData.height);

                // Set properties from copied plane
                newPlane.mesh.position.copy(planeData.position).add(offset);
                newPlane.mesh.rotation.copy(planeData.rotation);
                newPlane.mesh.scale.copy(planeData.scale);
                newPlane.mesh.material.color.setHex(planeData.color);

                // Update plane data with correct values
                newPlane.width = planeData.width * planeData.scale.x;
                newPlane.height = planeData.height * planeData.scale.y;
                newPlane.defaultWidth = planeData.width;
                newPlane.defaultHeight = planeData.height;
                newPlane.x = newPlane.mesh.position.x;
                newPlane.y = newPlane.mesh.position.y;
                newPlane.z = newPlane.mesh.position.z;
                newPlane.angle = planeData.rotation.y * (180 / Math.PI);
                newPlane.incline = planeData.rotation.x * (180 / Math.PI);
                newPlane.color = planeData.color;
                newPlane.temperature = planeData.temperature;
                newPlane.type = planeData.type;
                newPlane.positive = planeData.positive !== undefined ? planeData.positive : true;

                // Select the new plane
                newPlanes.push(newPlane);
                newPlane.mesh.material.color.setHex(0xe3e3e3);
            });

            selectedPlanes = [...newPlanes];

            // If original was a group, recreate the group structure
            if (clipboard.isGroup && selectedPlanes.length > 1) {
                createOrUpdateGroup();

                // Apply relative positions if available
                if (clipboard.relativePositions) {
                    selectedPlanes.forEach((plane, index) => {
                        if (clipboard.relativePositions[index]) {
                            plane.mesh.position.copy(clipboard.relativePositions[index]);
                        }
                    });
                    updateGroupPosition();
                }
            }

            // Update transform controls and GUI
            updateTransformControls();
            if (selectedPlanes.length > 0) {
                // Force GUI update with the correct values
                const lastPlane = selectedPlanes[selectedPlanes.length - 1];
                updateGUI(lastPlane);

                // Also update the mesh's userData to match
                lastPlane.mesh.userData = lastPlane;
            }

            console.log('Pasted from clipboard');
            captureState("After paste");
        }


        function showContourToSelectedPlane() {
            if (selectedPlanes.length === 0) {
                alert("Please select a plane first");
                return;
            }

            const selectedPlane = selectedPlanes[0]; // Use the first selected plane

            // Get modal elements
            const modal = document.getElementById("contourModal");
            const modalImg = document.getElementById("contourImage");
            const valueDisplay = document.getElementById("valueDisplay");
            const span = document.getElementsByClassName("close")[0];

            // Use uploaded contour if available, otherwise generate if missing
            if (!dataarrayforcontour) {
                if (uploadedContour && uploadedContour.values) {
                    dataarrayforcontour = uploadedContour.values;
                } else {
                    alert('Contour data not available. Please provide data from backend.');
                    return;
                }
            }

            // Calculate dimensions based on plane size for display
            const gridWidth = (uploadedContour && uploadedContour.width) ? uploadedContour.width : Math.round(selectedPlane.width) * 2;
            const gridHeight = (uploadedContour && uploadedContour.height) ? uploadedContour.height : Math.round(selectedPlane.height) * 2;

            // Generate the contour data based on plane dimensions
            const contourData = {
                width: gridWidth,
                height: gridHeight,
                values: dataarrayforcontour
            };

            // Calculate SVG dimensions based on plane aspect ratio and size
            const planeAspectRatio = selectedPlane.width / selectedPlane.height;
            const planeArea = selectedPlane.width * selectedPlane.height;

            // Scale base size based on plane area to maintain texture quality
            // For larger planes, use higher resolution textures
            let baseSize = 512; // Minimum base size
            if (planeArea > 25) { // If plane area is larger than 5x5
                baseSize = Math.max(512, Math.round(Math.sqrt(planeArea) * 100)); // Scale with plane size
            }

            let svgWidth, svgHeight;

            if (planeAspectRatio >= 1) {
                // Plane is wider than tall
                svgWidth = baseSize;
                svgHeight = Math.round(baseSize / planeAspectRatio);
            } else {
                // Plane is taller than wide
                svgHeight = baseSize;
                svgWidth = Math.round(baseSize * planeAspectRatio);
            }

            // Update SVG dimensions
            const svg = d3.select("#contour-svg");
            svg.attr("width", svgWidth).attr("height", svgHeight);
            svg.selectAll("*").remove();

            const n = contourData.width;
            const m = contourData.height;

            // Use fitSize to properly scale the projection to the SVG dimensions
            const projection = d3.geoIdentity().fitSize([svgWidth, svgHeight], {
                type: "Polygon",
                coordinates: [[[0, 0], [n, 0], [n, m], [0, m], [0, 0]]]
            });

            const path = d3.geoPath().projection(projection);
            const contours = d3.contours().size([n, m]);
            const color = d3.scaleSequential(d3.interpolateTurbo).domain(d3.extent(contourData.values)).nice();

            svg.append("g")
                .attr("stroke", "black")
                .selectAll()
                .data(color.ticks(20))
                .join("path")
                .attr("d", d => path(contours.contour(contourData.values, d)))
                .attr("fill", d => color(d));

            // Convert SVG to Canvas with matching dimensions
            const canvas = document.createElement('canvas');
            canvas.width = svgWidth;
            canvas.height = svgHeight;
            const ctx = canvas.getContext('2d');

            // Serialize SVG to string
            const svgString = new XMLSerializer().serializeToString(svg.node());
            const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(svgBlob);

            // Create image from SVG
            const img = new Image();
            img.onload = function () {
                ctx.drawImage(img, 0, 0);
                URL.revokeObjectURL(url);

                // Set the image source and show the modal
                modalImg.src = canvas.toDataURL();
                modal.style.display = "block";

                // Create value map from original data
                const valueMap = [];
                for (let y = 0; y < m; y++) {
                    valueMap[y] = [];
                    for (let x = 0; x < n; x++) {
                        valueMap[y][x] = contourData.values[y * n + x];
                    }
                }

                // Zoom variables
                let scale = 1;
                const minScale = 0.5;
                const maxScale = 5;
                const zoomFactor = 0.1;

                // Mouse wheel zoom handler
                function handleWheel(e) {
                    e.preventDefault();

                    // Calculate new scale
                    if (e.deltaY < 0) {
                        scale = Math.min(scale + zoomFactor, maxScale);
                    } else {
                        scale = Math.max(scale - zoomFactor, minScale);
                    }

                    // Apply the scale
                    modalImg.style.transform = `translate(-50%, -50%) scale(${scale})`;
                    modalImg.style.cursor = scale > 1 ? 'grab' : 'zoom-in';
                }

                // Mouse move handler to show values
                function handleMouseMove(e) {
                    const rect = modalImg.getBoundingClientRect();

                    // Calculate position relative to the scaled image
                    const imgX = (e.clientX - (rect.left + rect.width / 2 - (rect.width * scale) / 2)) / (rect.width * scale);
                    const imgY = (e.clientY - (rect.top + rect.height / 2 - (rect.height * scale) / 2)) / (rect.height * scale);

                    if (imgX >= 0 && imgX <= 1 && imgY >= 0 && imgY <= 1) {
                        // Map to data coordinates
                        const dataX = Math.floor(imgX * n);
                        const dataY = Math.floor(imgY * m);

                        // Clamp to valid range
                        const x = Math.max(0, Math.min(n - 1, dataX));
                        const y = Math.max(0, Math.min(m - 1, dataY));

                        const value = valueMap[y][x];

                        // Position display above cursor when near bottom
                        const displayAbove = (e.clientY > window.innerHeight - 100);

                        valueDisplay.style.display = 'block';
                        valueDisplay.style.left = `${e.clientX + 15}px`;
                        valueDisplay.style.top = `${e.clientY + (displayAbove ? -40 : 15)}px`;
                        valueDisplay.textContent = `Value: ${value.toFixed(2)}`;
                    } else {
                        valueDisplay.style.display = 'none';
                    }
                }

                // Mouse leave handler
                function handleMouseLeave() {
                    valueDisplay.style.display = 'none';
                }

                // Add event listeners
                modalImg.addEventListener('wheel', handleWheel, { passive: false });
                modalImg.addEventListener('mousemove', handleMouseMove);
                modalImg.addEventListener('mouseleave', handleMouseLeave);

                // Cleanup function
                function cleanup() {
                    modalImg.removeEventListener('wheel', handleWheel);
                    modalImg.removeEventListener('mousemove', handleMouseMove);
                    modalImg.removeEventListener('mouseleave', handleMouseLeave);
                    modal.style.display = "none";
                    modalImg.style.transform = 'translate(-50%, -50%) scale(1)';
                }

                // Close handlers
                span.onclick = cleanup;
                modal.onclick = function (e) {
                    if (e.target === modal) cleanup();
                };
                modalImg.onclick = function (e) {
                    e.stopPropagation();
                };
            };
            img.src = url;
        }

        // Add event listener to your contour button
        
        document.getElementById("detail").addEventListener("click", showContourToSelectedPlane);



        // Updated captureState function to handle all plane properties and new functionality
        function captureState(description = "User action") {
            // Don't capture during operations unless forced
            if (transformControlss && transformControlss.dragging) return;

            const state = {
                planes: planes.map(plane => ({
                    id: plane.id || generateId(), // Add unique IDs
                    position: plane.mesh.getWorldPosition(new THREE.Vector3()).clone(), // Store world position instead of local
                    rotation: plane.mesh.rotation.clone(),
                    scale: plane.mesh.scale.clone(),
                    width: plane.width,
                    height: plane.height,
                    // Store default values for reset functionality
                    defaultWidth: plane.defaultWidth,
                    defaultHeight: plane.defaultHeight,
                    defaultX: plane.defaultX,
                    defaultY: plane.defaultY,
                    defaultZ: plane.defaultZ,
                    defaultAngle: plane.defaultAngle,
                    defaultColor: plane.defaultColor,
                    // Store derived properties
                    x: plane.x,
                    y: plane.y,
                    z: plane.z,
                    angle: plane.angle,
                    incline: plane.incline,
                    color: plane.color,
                    temperature: plane.temperature,
                    type: plane.type,
                    name: plane.name,
                    selected: selectedPlanes.includes(plane),
                    // Store material properties including texture information
                    hasTexture: plane.mesh.material.map !== null,
                    textureData: plane.mesh.material.map ? {
                        isContourTexture: plane.mesh.material.map.isContourTexture || false,
                        contourData: plane.mesh.material.map.contourData || null
                    } : null
                })),
                groups: selectedPlaneGroup ? {
                    planeIds: selectedPlanes.map(p => p.id),
                    position: selectedPlaneGroup.position.clone(),
                    rotation: selectedPlaneGroup.rotation.clone(),
                    scale: selectedPlaneGroup.scale.clone()
                } : null,
                // Store scene state
                imagePlane: {
                    visible: imagePlane.visible,
                    position: imagePlane.position.clone(),
                    rotation: imagePlane.rotation.clone(),
                    scale: imagePlane.scale.clone(),
                    geometry: {
                        width: imagePlane.geometry.parameters.width,
                        height: imagePlane.geometry.parameters.height
                    }
                },
                // Store contour data if available
                contourData: dataarrayforcontour ? {
                    values: dataarrayforcontour,
                    timestamp: Date.now()
                } : null,
                description: description,
                timestamp: Date.now(),
                isPasteOperation: typeof description === 'string' && (description.includes("paste") || description.includes("Paste"))
            };

            // Trim history if needed
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }

            // Skip duplicate states
            if (history.length > 0) {
                const last = history[history.length - 1];
                if (JSON.stringify(last) === JSON.stringify(state)) return;
            }

            history.push(state);
            historyIndex = history.length - 1;

            // Limit history size
            if (history.length > MAX_HISTORY_STEPS) {
                history.shift();
                historyIndex--;
            }

            console.log(`State captured: ${description} - Total planes: ${planes.length}, Selected: ${selectedPlanes.length}`);
            console.log(`Plane IDs in state: ${state.planes.map(p => p.id).join(', ')}`);
        }


        // Remove duplicate event listener - this functionality is already handled in the main dragging-changed listener

        // Updated restoreState function to handle all plane properties and new functionality
        function restoreState(index) {
            if (index < 0 || index >= history.length) return;

            const state = history[index];
            console.log(`Restoring state: ${state.description || 'Unknown'}`);

            // Clear current selection and groups
            selectedPlanes = [];
            if (selectedPlaneGroup) {
                ungroupPlanes();
            }

            // First pass: update existing planes or create new ones
            const newPlanes = [];
            state.planes.forEach(planeState => {
                let plane = planes.find(p => p.id === planeState.id);

                if (!plane) {
                    // Create new plane
                    plane = createPlane(planeState.width, planeState.height);
                    plane.id = planeState.id;
                    console.log(`Created new plane with ID: ${planeState.id}`);
                } else {
                    console.log(`Found existing plane with ID: ${planeState.id}`);
                }

                // Ensure the plane is in the scene
                if (!scene.children.includes(plane.mesh)) {
                    scene.add(plane.mesh);
                }

                // For paste operations, ensure we're restoring to the exact state
                if (state.isPasteOperation) {
                    console.log(`Restoring paste operation state for plane ${planeState.id}`);
                }

                // Update all plane properties including defaults
                if (planeState.defaultWidth !== undefined) plane.defaultWidth = planeState.defaultWidth;
                if (planeState.defaultHeight !== undefined) plane.defaultHeight = planeState.defaultHeight;
                if (planeState.defaultX !== undefined) plane.defaultX = planeState.defaultX;
                if (planeState.defaultY !== undefined) plane.defaultY = planeState.defaultY;
                if (planeState.defaultZ !== undefined) plane.defaultZ = planeState.defaultZ;
                if (planeState.defaultAngle !== undefined) plane.defaultAngle = planeState.defaultAngle;
                if (planeState.defaultColor !== undefined) plane.defaultColor = planeState.defaultColor;

                // Update current properties
                plane.mesh.rotation.copy(planeState.rotation);
                plane.mesh.scale.copy(planeState.scale);
                plane.width = planeState.width;
                plane.height = planeState.height;
                plane.color = planeState.color;
                plane.temperature = planeState.temperature;
                plane.type = planeState.type;
                plane.name = planeState.name;
                plane.positive = planeState.positive !== undefined ? planeState.positive : true;
                plane.mesh.material.color.setHex(planeState.color);

                // Update derived properties
                plane.x = planeState.position.x;
                plane.y = planeState.position.y;
                plane.z = planeState.position.z;
                plane.angle = planeState.rotation.y * (180 / Math.PI);
                plane.incline = planeState.rotation.x * (180 / Math.PI);

                // Handle texture restoration if available
                if (planeState.hasTexture && planeState.textureData) {
                    if (planeState.textureData.isContourTexture && planeState.textureData.contourData) {
                        // Restore contour texture
                        restoreContourTexture(plane, planeState.textureData.contourData);
                    }
                }

                if (planeState.selected) {
                    selectedPlanes.push(plane);
                    plane.mesh.material.color.setHex(0xe3e3e3);
                } else {
                    plane.mesh.material.color.setHex(plane.color);
                }

                newPlanes.push(plane);
            });

            // Remove planes that shouldn't exist in this state
            const planesToRemove = planes.filter(p => !state.planes.some(s => s.id === p.id));
            planesToRemove.forEach(plane => {
                console.log(`Removing plane with ID: ${plane.id}`);
                if (scene.children.includes(plane.mesh)) {
                    scene.remove(plane.mesh);
                }
                plane.mesh.geometry.dispose();
                plane.mesh.material.dispose();
            });

            // Update planes array
            planes.splice(0, planes.length, ...newPlanes);

            // Set positions for all planes first (before grouping)
            newPlanes.forEach(plane => {
                const planeState = state.planes.find(p => p.id === plane.id);
                if (planeState) {
                    plane.mesh.position.copy(planeState.position);
                    console.log(`Set plane ${plane.id} position to: ${planeState.position}`);
                }
            });

            // Restore group if needed
            if (state.groups) {
                selectedPlanes = planes.filter(p => state.groups.planeIds.includes(p.id));

                // Create group without calling captureState (we'll do it manually)
                if (!selectedPlaneGroup) {
                    selectedPlaneGroup = new THREE.Group();
                    scene.add(selectedPlaneGroup);
                    originalPositions = new Map();
                }

                // Clear existing planes from group
                while (selectedPlaneGroup.children.length > 0) {
                    selectedPlaneGroup.remove(selectedPlaneGroup.children[0]);
                }

                // Add planes to group and store their original positions
                selectedPlanes.forEach(plane => {
                    const planeState = state.planes.find(p => p.id === plane.id);
                    if (planeState) {
                        // Store original world position
                        originalPositions.set(plane, {
                            worldPosition: planeState.position.clone(),
                            parent: scene
                        });

                        // Add to group (position is already set)
                        selectedPlaneGroup.add(plane.mesh);

                        console.log(`Added plane ${plane.id} to group with position: ${plane.mesh.position}`);
                    }
                });

                // Set group position
                selectedPlaneGroup.position.copy(state.groups.position);
                selectedPlaneGroup.rotation.copy(state.groups.rotation);
                selectedPlaneGroup.scale.copy(state.groups.scale);

                console.log(`Set group position to: ${state.groups.position}`);
            }

            // Restore image plane state if available
            if (state.imagePlane) {
                imagePlane.visible = state.imagePlane.visible;
                imagePlane.position.copy(state.imagePlane.position);
                imagePlane.rotation.copy(state.imagePlane.rotation);
                imagePlane.scale.copy(state.imagePlane.scale);

                // Update geometry if dimensions changed
                if (state.imagePlane.geometry) {
                    imagePlane.geometry.dispose();
                    imagePlane.geometry = new THREE.PlaneGeometry(
                        state.imagePlane.geometry.width,
                        state.imagePlane.geometry.height
                    );
                }
            }

            // Restore contour data if available
            if (state.contourData && state.contourData.values) {
                dataarrayforcontour = state.contourData.values;
                console.log(`Restored contour data with ${dataarrayforcontour.length} values`);
            }

            // Update GUI and controls
            updateTransformControls();
            if (selectedPlanes.length > 0) {
                updateGUI(selectedPlanes[selectedPlanes.length - 1]);
            }

            // Update GUI
            gui.destroy();
            gui = new dat.GUI();

            console.log(`State restoration complete. Total planes: ${planes.length}, Selected: ${selectedPlanes.length}`);
            console.log(`Current plane IDs: ${planes.map(p => p.id).join(', ')}`);
            console.log(`Selected plane IDs: ${selectedPlanes.map(p => p.id).join(', ')}`);

            // Debug: Log final positions of all planes
            planes.forEach(plane => {
                const worldPos = plane.mesh.getWorldPosition(new THREE.Vector3());
                console.log(`Final plane ${plane.id}: local=${plane.mesh.position}, world=${worldPos}`);
            });

            if (selectedPlaneGroup) {
                console.log(`Group position: ${selectedPlaneGroup.position}`);
                console.log(`Group children: ${selectedPlaneGroup.children.length}`);
            }
        }

        // Helper function to restore contour textures
        function restoreContourTexture(plane, contourData) {
            try {
                // Create a new canvas with the contour data
                const gridWidth = Math.round(plane.width) * 2;
                const gridHeight = Math.round(plane.height) * 2;

                // Calculate SVG dimensions based on plane aspect ratio
                const planeAspectRatio = plane.width / plane.height;
                let baseSize = 512;
                if (plane.width * plane.height > 25) {
                    baseSize = Math.max(512, Math.round(Math.sqrt(plane.width * plane.height) * 100));
                }

                let svgWidth, svgHeight;
                if (planeAspectRatio >= 1) {
                    svgWidth = baseSize;
                    svgHeight = Math.round(baseSize / planeAspectRatio);
                } else {
                    svgHeight = baseSize;
                    svgWidth = Math.round(baseSize * planeAspectRatio);
                }

                // Create SVG and generate contour
                const svg = d3.select("#contour-svg");
                svg.attr("width", svgWidth).attr("height", svgHeight);
                svg.selectAll("*").remove();

                const n = gridWidth;
                const m = gridHeight;

                const projection = d3.geoIdentity().fitSize([svgWidth, svgHeight], {
                    type: "Polygon",
                    coordinates: [[[0, 0], [n, 0], [n, m], [0, m], [0, 0]]]
                });

                const path = d3.geoPath().projection(projection);
                const contours = d3.contours().size([n, m]);
                const color = d3.scaleSequential(d3.interpolateTurbo).domain(d3.extent(contourData)).nice();

                svg.append("g")
                    .attr("stroke", "black")
                    .selectAll()
                    .data(color.ticks(20))
                    .join("path")
                    .attr("d", d => path(contours.contour(contourData, d)))
                    .attr("fill", d => color(d));

                // Convert SVG to texture
                const canvas = document.createElement('canvas');
                canvas.width = svgWidth;
                canvas.height = svgHeight;
                const ctx = canvas.getContext('2d');

                const svgString = new XMLSerializer().serializeToString(svg.node());
                const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(svgBlob);

                const img = new Image();
                img.onload = function () {
                    ctx.drawImage(img, 0, 0);
                    URL.revokeObjectURL(url);

                    const texture = new THREE.CanvasTexture(canvas);
                    texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.generateMipmaps = false;

                    // Mark as contour texture for future state captures
                    texture.isContourTexture = true;
                    texture.contourData = contourData;

                    plane.mesh.material.map = texture;
                    plane.mesh.material.needsUpdate = true;
                    plane.mesh.material.color.set(0xffffff);

                    console.log(`Restored contour texture for plane ${plane.id}`);
                };
                img.src = url;
            } catch (error) {
                console.error(`Error restoring contour texture for plane ${plane.id}:`, error);
            }
        }



        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, activeCamera);
            labelRenderer.render(scene, activeCamera);
        }
        animate();

        // Handle window resize
        window.addEventListener("resize", () => {
            cameras.perspective.aspect = window.innerWidth / window.innerHeight;
            cameras.perspective.updateProjectionMatrix();
            activeCamera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            updateOrthoCameras();

            // Update transform controls if they exist
            if (transformControlss) {
                transformControlss.camera = activeCamera;
            }
        });
    </script>
</body>

</html>

