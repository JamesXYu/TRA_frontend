<!DOCTYPE html>
<html>

<head>
    <title>Radiation 3D prototype</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
        }

        #functionbox {
            width: 250px;
            height: auto;
            position: absolute;
            top: 50px;
            bottom: 10px;
            left: 10px;
            z-index: 100;

            background-color: #b5cea8;
            background-color: #4444447e;
            border-radius: 4px;
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
        }

        #renderbody {
            width: 100%;
            height: 100vh;
        }

        #deleteplane {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #deleteplane:hover {
            background: #007e7a;
        }

        #deleteplane:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }

        .custom-file-upload {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: 22px;
            padding: 8px 16px;
            background: #00a19b;
            width: 168px;
            height: 32px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        .custom-file-upload:hover {
            background-color: #007e7a;
        }

        .custom-file-upload:active {
            transform: scale(0.97);
        }

        #addplane {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #addplane:hover {
            background: #007e7a;
        }

        #top {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 400;
            font-size: large;
            padding: 5px 16px;
            background: #00a19b;
            width: 60px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 15px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #top:hover {
            background: #007e7a;
        }

        #front {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: large;
            padding: 8px 16px;
            background: #00a19b;
            width: 60px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #front:hover {
            background: #007e7a;
        }

        #side {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 400;
            font-size: large;
            padding: 8px 16px;
            background: #00a19b;
            width: 60px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #side:hover {
            background: #007e7a;
        }

        #perspective {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #perspective:hover {
            background: #007e7a;
        }

        #renderbody {
            position: relative;
            width: 100%;
            height: 100vh;
            margin: 0;
            padding: 0;
        }

        /* Add this to your existing style section */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
        }
        
        .modal-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            gap: 30px;
            max-width: 90vw;
            max-height: 90vh;
        }

        #valueDisplay {
            position: fixed;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            pointer-events: none;
            font-family: Arial, sans-serif;
            font-size: 14px;
            z-index: 1001;
            white-space: nowrap;
        }

        .modal-content {
            display: block;
            transform-origin: center center;
            transition: transform 0.1s ease-out;
            cursor: zoom-in;
            max-width: 70vw;
            max-height: 85vh;
            object-fit: contain;
            transform: scaleY(-1);
        }

        .close {
            position: absolute;
            top: 15px;
            right: 35px;
            color: white;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1003;
        }

        #scalinginput, #gridSizeInput {
            padding: 6px 8px;
            font-size: 20px;
            font-family: 'Poppins', sans-serif;
            border: 1px solid #ccc;
            border-radius: 8px;
            outline: none;
            margin-left: 25px;
            width: 200px;
            max-width: 185px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
            margin-top: 5px;
            margin-bottom: 5px;
        }
        
        #colorScaleMin, #colorScaleMax {
            padding: 6px 8px;
            font-size: 18px;
            font-family: 'Poppins', sans-serif;
            border: 1px solid #ccc;
            border-radius: 8px;
            outline: none;
            width: 65px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
            margin: 5px 5px;
        }
        
        .color-scale-container {
            display: flex;
            align-items: center;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #scalinginput:placeholder, #gridSizeInput:placeholder, #colorScaleMin:placeholder, #colorScaleMax:placeholder {
            color: #aaa;
        }

        #scalinginput:focus, #gridSizeInput:focus, #colorScaleMin:focus, #colorScaleMax:focus {
            border-color: #4a90e2;
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.2);
        }

        #scalingbutton {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #scalingbutton:hover {
            background: #007e7a;
        }

        #updatescale {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #updatescale:hover {
            background: #007e7a;
        }

        #exportBtn {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #exportBtn:hover {
            background: #007e7a;
        }

        #resetPlane {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #resetPlane:hover {
            background: #007e7a;
        }

        #standPlane {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #standPlane:hover {
            background: #007e7a;
        }


        #importbtn {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: 24px;
            padding: 8px 16px;
            background: #00a19b;
            width: 168px;
            height: 32px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #importbtn:hover {
            background-color: #007e7a;
        }

        #importbtn:active {
            transform: scale(0.97);
        }

        #detail {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #detail:hover {
            background: #007e7a;
        }

        #calculate {
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Poppins', sans-serif;
            font: 700;
            font-size: x-large;
            padding: 8px 16px;
            background: #00a19b;
            width: 200px;
            height: 50px;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 25px;
            margin-top: 5px;
            margin-bottom: 5px;
        }

        #calculate:hover {
            background: #007e7a;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            outline: none;
        }

        hr {
            border: none;
            border-top: 1px solid #444;
            margin: 10px 0;
        }

        p {
            font: bolder;
            font-size: 24px;
            font-family: 'Poppins', sans-serif;
            text-align: center;
            margin: 5px 0 10px 0;
            font-weight: bold;
            color: aliceblue;
        }

        .my-custom-gui {
            font-size: 26px;
            width: 700px;
            background-color: #222;
            border-radius: 10px;
            padding: 20px;
        }

        /* Bigger dat.GUI with your color scheme */
        .dg.main {
            font-family: 'Poppins', sans-serif !important;
            font-size: 20px !important;
            background-color: rgba(68, 68, 68, 0.8) !important;
            border-radius: 4px !important;
            width: 500px !important;
        }

        .dg .cr {
            height: 40px !important;
            line-height: 40px !important;
            border-bottom: 1px solid #444 !important;
        }

        .dg .c input[type=text] {
            height: 28px !important;
            font-size: 20px !important;
            background: #555 !important;
            color: white !important;
            border: 1px solid #666 !important;
            border-radius: 4px !important;
            font-family: 'Poppins', sans-serif;
            font: 700;
            width: 100% !important;
            margin-left: 0 !important;
        }

        .dg .c select {
            height: 34px !important;
            font-size: 20px !important;
            background: #555 !important;
            color: white !important;
            border: 1px solid #666 !important;
            border-radius: 4px !important;
            font-family: 'Poppins', sans-serif;
            font: 700;
            width: 102% !important;
            margin-left: -7px !important;
        }

        .dg .c select option {
            border-radius: 8px;
            padding: 4px 8px;
        }
        

        .dg .c .slider {
            display: none !important;
        }

        .dg .c .slider-fg {
            background: #00a19b !important;
            height: 24px !important;
        }

        .dg .c .slider:hover .slider-fg {
            background: #007e7a !important;
        }

        .dg .title {
            font-size: 18px !important;
            padding: 8px 10px !important;
            background-color: rgba(0, 161, 155, 0.3) !important;
        }

        .dg .cr.function .property-name {
            color: white !important;
            font-weight: 500 !important;
        }

        .dg .cr.function:hover {
            background: rgba(0, 161, 155, 0.2) !important;
        }

        .dg .cr.number .property-name,
        .dg .cr.boolean .property-name {
            color: white !important;
            font-weight: 500 !important;
        }

        /* Make checkbox bigger to fit the larger GUI */
        .dg .cr.boolean input[type="checkbox"] {
            width: 20px !important;
            height: 20px !important;
        }

        .dg .cr.boolean .checkbox {
            width: 20px !important;
            height: 20px !important;
        }

        .dg.main .close-button {
            display: none !important;
        }

        .dg.main .close-button:hover {
            background-color: #007e7a !important;
        }

        .view-buttons-container {
            display: flex;
            justify-content: center;
        }

        #colorLegend {
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            font-family: 'Poppins', sans-serif;
            min-width: 200px;
        }

        #colorLegend h3 {
            margin: 0 0 10px 0;
            font-size: 18px;
            text-align: center;
            color: #333;
        }
        
        #colorLegend .data-range-info {
            margin-top: 15px;
            padding: 10px;
            background: rgba(255, 255, 200, 0.3);
            border-radius: 4px;
            font-size: 12px;
            color: #333;
            border: 1px solid #ccc;
        }
        
        #colorLegend .data-range-info strong {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
        }

        .legend-gradient {
            width: 40px;
            height: 300px;
            border: 2px solid #333;
            border-radius: 4px;
            margin: 0 auto;
        }

        .legend-labels {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 300px;
            margin-left: 10px;
            font-size: 14px;
            color: #333;
        }

        .legend-container {
            display: flex;
            align-items: center;
        }
    </style>

</head>

<body>

    <div id="functionbox">
        <p>Floor plan</p>
        <input type="file" id="imageInput" accept="image/*" hidden>
        <label for="imageInput" class="custom-file-upload">Upload Image</label>
        <hr>
        <p>Plane</p>
        <button id="addplane"> Add Plane </button>
        <button id="deleteplane">Delete Plane </button>
        <button id="resetPlane">Reset Plane</button>
        <button id="standPlane">Stand Plane</button>
        <hr>
        <p>Views</p>
        <div class="view-buttons-container">
            <button id="top">Top</button>
            <button id="front"> Front</button>
            <button id="side">Side</button>
        </div>
        <button id="perspective">Perspective</button>
        <hr>
        <p>Scaling</p>
        <input type="text" name="Set scale" id="scalinginput" placeholder="Enter the distance">
        <button id="scalingbutton"> Set scale </button>
        <button id="updatescale"> Update </button>
        <hr>
        <p>Precision</p>
        <input type="number" id="gridSizeInput" placeholder="Receiver grid size (1-50)" min="1" max="50">
        <hr>
        <p>Color Scale</p>
        <div class="color-scale-container">
            <input type="number" id="colorScaleMin" placeholder="Min" step="0.1" value="0">
            <span style="color: white; font-family: 'Poppins', sans-serif;">to</span>
            <input type="number" id="colorScaleMax" placeholder="Max" step="0.1" value="20">
        </div>
        <hr>
        <p>Save</p>
        <button id="exportBtn"> Export Scene</button>
        <input type="file" id="importFile" accept=".json" hidden>
        <label for="importFile" id="importbtn"> Import Scene </label>
        <hr>
        <p>Calculation</p>
        <button id="detail">Show detail</button>
        <button id="calculate">Calculate</button>
        

    </div>
    <svg id="contour-svg" width="512" height="512" style="display:none;"></svg>
    <div id="renderbody"></div>
    <div id="contourModal" class="modal">
        <span class="close">&times;</span>
        <div id="valueDisplay"></div>
        <div class="modal-container">
            <img id="contourImage" class="modal-content">
            <div id="colorLegend">
                <h3>Heat Flux Scale</h3>
                <div class="legend-container">
                    <div class="legend-gradient" id="legendGradient"></div>
                    <div class="legend-labels" id="legendLabels"></div>
                </div>
            </div>
        </div>
    </div>
    <svg id="contour-svg" width="512" height="512" style="display:none;"></svg>

    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.7/build/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3-contour@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/renderers/CSS2DRenderer.js"></script>

    <script>
        // Configuration
        const CONFIG = {
            // Backend API URL - Change this to your deployed backend URL
            BACKEND_URL: 'http://localhost:8080', // For local development
            // BACKEND_URL: 'https://your-app.onrender.com', // For Render.com deployment
            // BACKEND_URL: 'https://your-domain.com', // For custom domain
            
            // API endpoints
            CALCULATE_ENDPOINT: '/calculate',
            HEALTH_ENDPOINT: '/health',
            STATUS_ENDPOINT: '/status',
            
            // Request settings
            REQUEST_TIMEOUT: 60000, // 60 seconds
            MAX_RETRIES: 3
        };
        
        console.log("Radiation 3D Application loaded with config:", CONFIG);

        // Backend communication utilities
        async function checkBackendHealth() {
            try {
                const response = await fetch(CONFIG.BACKEND_URL + CONFIG.HEALTH_ENDPOINT, {
                    method: 'GET',
                    timeout: 5000
                });
                return response.ok;
            } catch (error) {
                console.warn('Backend health check failed:', error);
                return false;
            }
        }

        async function getBackendStatus() {
            try {
                const response = await fetch(CONFIG.BACKEND_URL + CONFIG.STATUS_ENDPOINT, {
                    method: 'GET',
                    timeout: 5000
                });
                if (response.ok) {
                    return await response.json();
                }
                return null;
            } catch (error) {
                console.warn('Backend status check failed:', error);
                return null;
            }
        }

        // Test backend connection on page load
        async function testBackendConnection() {
            console.log('Testing backend connection...');
            const isHealthy = await checkBackendHealth();
            if (isHealthy) {
                console.log('✅ Backend is healthy');
                const status = await getBackendStatus();
                if (status) {
                    console.log('Backend status:', status);
                }
            } else {
                console.warn('⚠️ Backend is not responding. Check your configuration.');
                console.log('Current backend URL:', CONFIG.BACKEND_URL);
            }
        }

        // Add these variables near the top with your other variables
        let history = [];
        let groupDragStartPosition = null;
        let historyIndex = -1;
        const MAX_HISTORY_STEPS = 500; // Prevent memory bloat
        function initializeHistory() {
            // Capture initial state with all plane properties
            const initialState = planes.map(plane => ({
                id: plane.id || generateId(),
                position: plane.mesh.getWorldPosition(new THREE.Vector3()).clone(),
                rotation: plane.mesh.rotation.clone(),
                scale: plane.mesh.scale.clone(),
                width: plane.width,
                height: plane.height,
                // Store default values
                defaultWidth: plane.defaultWidth,
                defaultHeight: plane.defaultHeight,
                defaultX: plane.defaultX,
                defaultY: plane.defaultY,
                defaultZ: plane.defaultZ,
                defaultAngle: plane.defaultAngle,
                defaultColor: plane.defaultColor,
                // Store derived properties
                x: plane.x,
                y: plane.y,
                z: plane.z,
                angle: plane.angle,
                incline: plane.incline,
                color: plane.color,
                temperature: plane.temperature,
                type: plane.type,
                name: plane.name,
                selected: false,
                // Store material properties
                hasTexture: plane.mesh.material.map !== null,
                textureData: plane.mesh.material.map ? {
                    isContourTexture: plane.mesh.material.map.isContourTexture || false,
                    contourData: plane.mesh.material.map.contourData || null
                } : null
            }));

            history = [initialState];
            historyIndex = 0;
            console.log("Initial history state captured with full plane properties");
        }



        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                restoreState(historyIndex);
            } else {
                console.log("No more undo steps available.");
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                restoreState(historyIndex);
            } else {
                console.log("No more redo steps available.");
            }
        }

        // Replace the current keyboard event listener with this:
        window.addEventListener('keydown', (event) => {
            if (event.ctrlKey || event.metaKey) {
                if (event.key === 'z' && !event.shiftKey) {
                    undo();
                    event.preventDefault();
                } else if ((event.key === 'y' || (event.shiftKey && event.key === 'z'))) {
                    redo();
                    event.preventDefault();
                }
            }
        });

        // Add event listeners for buttons
        document.getElementById('undoBtn')?.addEventListener('click', undo);
        document.getElementById('redoBtn')?.addEventListener('click', redo);

        // Now we need to capture states at key moments. Add these calls:

        const scene = new THREE.Scene();
        scene.background = new THREE.Color("#222");


        //set up different camera parameters
        const frustumSize = 40;
        const cameras = {
            perspective: new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000),
            top: new THREE.OrthographicCamera(),
            front: new THREE.OrthographicCamera(),
            left: new THREE.OrthographicCamera()
        }

        cameras.perspective.position.set(10, 10, 10);
        cameras.top.position.set(0, 10, 0);
        cameras.top.lookAt(0, 0, 0);
        cameras.front.position.set(0, 0, 10);
        cameras.front.lookAt(0, 0, 0);
        cameras.left.position.set(-10, 0, 0);
        cameras.left.lookAt(0, 0, 0);

        for (const key in cameras) cameras[key].lookAt(0, 0, 0);
        let activeCamera = cameras.perspective;

        function updateOrthoCameras() {
            const aspect = window.innerWidth / window.innerHeight;
            for (const key of ['top', 'front', 'left']) {
                const cam = cameras[key];
                cam.left = frustumSize * aspect / -2; cam.right = frustumSize * aspect / 2;
                cam.top = frustumSize / 2; cam.bottom = frustumSize / -2;
                cam.near = 0.1; cam.far = 1000;
                cam.updateProjectionMatrix();
            }
        }

        updateOrthoCameras();

        document.getElementById('perspective').addEventListener('click', () => setView(cameras.perspective));
        document.getElementById('top').addEventListener('click', () => {
            setView(cameras.top)
        });
        document.getElementById('front').addEventListener('click', () => {
            setView(cameras.front)
        });
        document.getElementById('side').addEventListener('click', () => {
            setView(cameras.left)
        });

        // At the top with your other variables
        let selectedPlanes = []; // Array to store multiple selected planes
        let isShiftPressed = false; // Track shift key state
        // Add these near your other variables
        let selectedPlaneGroup = null; // Will store the temporary group
        let originalPositions = new Map(); // Stores original positions before grouping
        let normalArrow = null; // Arrow to visualize the normal direction
        let showNormalArrow = true; // Toggle for showing normal arrow

        // Add these near your other event listeners (like the keydown for transform controls)
        window.addEventListener('keydown', (event) => {
            if (event.key === 'Shift') {
                isShiftPressed = true;
            }
        });

        window.addEventListener('keyup', (event) => {
            if (event.key === 'Shift') {
                isShiftPressed = false;
            }
        });


        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.shadowMap.enabled = true;
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById("renderbody").appendChild(renderer.domElement);


        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);


        // Add a grid (hidden by default) with snapping-compatible size
        const gridSize = 50;
        const gridDivisions = 50;
        const grid = new THREE.GridHelper(gridSize, gridDivisions, 0xffffff, 0xffffff);
        scene.add(grid);

        // Grid snapping configuration
        const gridSnapConfig = {
            translation: {
                enabled: true,
                size: 0.5 // Grid unit size for translation
            },
            rotation: {
                enabled: true,
                increment: Math.PI / 12 // 15 degrees in radians
            },
            scale: {
                enabled: true,
                increment: 0.5,
                minScale: 0.1
            }
        };

        // Grid snapping utility functions
        function snapToGrid(value, gridSize) {
            return Math.round(value / gridSize) * gridSize;
        }

        function snapRotation(angle, increment) {
            return Math.round(angle / increment) * increment;
        }

        function snapScale(scale, increment, minScale) {
            const snapped = Math.round(scale / increment) * increment;
            return Math.max(snapped, minScale);
        }

        // Add CSS2DRenderer for axis labels
        const labelRenderer = new THREE.CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none';
        document.body.appendChild(labelRenderer.domElement);

        // Create axis indicator labels
        function createAxisLabel(text, position, color) {
            const labelDiv = document.createElement('div');
            labelDiv.textContent = text;
            labelDiv.style.color = '#ffffff'; // White text
            labelDiv.style.fontSize = '24px';
            labelDiv.style.fontWeight = 'bold';
            labelDiv.style.fontFamily = 'Arial, sans-serif';
            labelDiv.style.textShadow = '1px 1px 2px rgba(0,0,0,0.8)'; // Black shadow for contrast
            labelDiv.style.pointerEvents = 'none';
            
            const label = new THREE.CSS2DObject(labelDiv);
            label.position.copy(position);
            return label;
        }

        // Add axis labels (positioned further away)
        const xLabel = createAxisLabel('+X', new THREE.Vector3(70, 0, 0), '#ff0000');
        const xNegLabel = createAxisLabel('-X', new THREE.Vector3(-70, 0, 0), '#ff0000');
        const zLabel = createAxisLabel('+Z', new THREE.Vector3(0, 0, 70), '#0000ff');
        const zNegLabel = createAxisLabel('-Z', new THREE.Vector3(0, 0, -70), '#0000ff');

        scene.add(xLabel);
        scene.add(xNegLabel);
        scene.add(zLabel);
        scene.add(zNegLabel);

        // Add colorful axis lines
        function createAxisLine(origin, direction, color, length = 10) {
            const geometry = new THREE.BufferGeometry().setFromPoints([
                origin,
                new THREE.Vector3().copy(origin).add(direction.clone().multiplyScalar(length))
            ]);
            const material = new THREE.LineBasicMaterial({ 
                color: color, 
                linewidth: 5,
                depthTest: false,  // Disable depth testing to prevent z-fighting
                transparent: true,
                opacity: 0.8
            });
            const line = new THREE.Line(geometry, material);
            return line;
        }

        // Create axis lines (positioned slightly above grid to avoid z-fighting)
        const xAxis = createAxisLine(new THREE.Vector3(-70, 0.1, 0), new THREE.Vector3(1, 0, 0), 0xff0000, 140);
        const zAxis = createAxisLine(new THREE.Vector3(0, 0.1, -70), new THREE.Vector3(0, 0, 1), 0x0000ff, 140);

        scene.add(xAxis);
        scene.add(zAxis);

        // Create a plane for the image (initially invisible)
        const planeGeometry = new THREE.PlaneGeometry(10, 10);
        const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xeeeeee });
        const imagePlane = new THREE.Mesh(planeGeometry, planeMaterial);
        imagePlane.rotation.x = -Math.PI / 2; // Rotate to lie flat
        imagePlane.visible = false; // Hide until image loads
        scene.add(imagePlane);

        // OrbitControls for interaction
        const controls = new THREE.OrbitControls(activeCamera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.rotateSpeed = 0.4;

        controls.update();

        function setView(camera) {

            controls.reset();

            activeCamera = camera;
            controls.object = camera;
            transformControlss.camera = camera;

            if (camera === cameras.top) {
                camera.position.set(0, 10, 0);
                camera.lookAt(0, 0, 0);
                camera.rotation.set(0, 0, 0);
                camera.up.set(0, 0, -1); // Ensure consistent up vector for top view
            } else if (camera === cameras.front) {
                camera.position.set(0, 0, 10);
                camera.lookAt(0, 0, 0);
                camera.rotation.set(0, 0, 0);
                camera.up.set(0, 1, 0);
            } else if (camera === cameras.left) {
                camera.position.set(-10, 0, 0);
                camera.lookAt(0, 0, 0);
                camera.rotation.set(0, 0, 0);
                camera.up.set(0, 1, 0);
            }

            // Update projection matrices
            if (camera.isOrthographicCamera) {
                updateOrthoCameras();
            }

            // Toggle top view lines based on camera
            const isTopView = (camera === cameras.top);

            // Clean up existing top view lines
            planes.forEach(plane => {
                if (plane.mesh.userData.topViewLine) {
                    scene.remove(plane.mesh.userData.topViewLine);
                    plane.mesh.userData.topViewLine = null;
                }
                plane.mesh.visible = true; // Make sure all planes are visible by default
            });

            // Detach transform controls if they're attached to a top view line
            if (transformControlss && transformControlss.object) {
                // Check if transform controls are attached to a top view line
                const isTopViewLine = transformControlss.object.userData && transformControlss.object.userData.parentPlane;
                if (isTopViewLine) {
                    transformControlss.detach();
                }
            }

            // If in top view, create top view lines
            if (isTopView) {
                planes.forEach(plane => {
                    createTopViewLine(plane);
                });
            }

            if (camera.isPerspectiveCamera) {
                controls.mouseButtons.LEFT = THREE.MOUSE.ROTATE;
                controls.mouseButtons.RIGHT = THREE.MOUSE.PAN;
                controls.enableRotate = true;
            } else {
                controls.mouseButtons.LEFT = THREE.MOUSE.PAN;
                controls.mouseButtons.RIGHT = THREE.MOUSE.ROTATE;
                controls.enableRotate = false;
            }
            controls.update();
            
            // Update transform controls to apply view-specific settings
            updateTransformControls();
        }
        // setView(activeCamera);

        // Function to create top view line for a plane
        function createTopViewLine(plane) {
            // Create a line geometry representing the plane's length with fixed width
            const lineGeometry = new THREE.BufferGeometry();
            
            // Use the plane's width as the line length, with fixed width of 0.5
            const lineLength = plane.width;
            const fixedWidth = 0.3;
            
            // Create points for a simple line representing the plane's length
            const points = [
                new THREE.Vector3(-lineLength/2, 0, -fixedWidth/2),
                new THREE.Vector3(lineLength/2, 0, -fixedWidth/2),
                new THREE.Vector3(lineLength/2, 0, fixedWidth/2),
                new THREE.Vector3(-lineLength/2, 0, fixedWidth/2),
                new THREE.Vector3(-lineLength/2, 0, -fixedWidth/2) // Close the loop
            ];
            
            // Apply the plane's rotation to the points
            const rotationMatrix = new THREE.Matrix4();
            rotationMatrix.makeRotationFromEuler(new THREE.Euler(
                plane.incline * Math.PI / 180,
                plane.angle * Math.PI / 180,
                0
            ));
            
            points.forEach(point => {
                point.applyMatrix4(rotationMatrix);
            });
            
            lineGeometry.setFromPoints(points);
            
            // Create line material with plane's color
            const lineMaterial = new THREE.LineBasicMaterial({
                color: plane.color, // Use plane's color
                linewidth: 10
            });
            
            // Create the line mesh
            const line = new THREE.Line(lineGeometry, lineMaterial);
            
            // Position the line at the plane's position
            line.position.copy(plane.mesh.position);
            
            // Store reference to the parent plane
            line.userData.parentPlane = plane;
            
            // Store reference to the line in the plane's userData
            plane.mesh.userData.topViewLine = line;
            
            // Add to scene
            scene.add(line);
        }

        // Function to update top view line when plane changes
        function updateTopViewLine(plane) {
            if (plane.mesh.userData.topViewLine) {
                // Remove old line
                scene.remove(plane.mesh.userData.topViewLine);
                
                // Create new line with updated dimensions
                createTopViewLine(plane);
            }
        }

        // Function to update top view line color
        function updateTopViewLineColor(plane, color) {
            if (activeCamera === cameras.top && plane.mesh.userData.topViewLine) {
                plane.mesh.userData.topViewLine.material.color.setHex(color);
            }
        }

        // Function to visualize the normal direction of a receiver plane
        function visualizeNormal(plane) {
            // Remove existing arrow if any
            removeNormalArrow();
            
            console.log(`📍 visualizeNormal called for plane: "${plane.name}", type: "${plane.type}", showNormalArrow: ${showNormalArrow}`);
            
            // Check if visualization is enabled
            if (!showNormalArrow) {
                console.log(`⚠️ Normal arrow visualization is disabled. Click "Show Normal ✓" button to enable.`);
                return;
            }
            
            // Only show for receiver planes
            if (plane.type !== "Receiver") {
                console.log(`⚠️ Normal arrows only show for Receiver planes. Current type: "${plane.type}"`);
                return;
            }
            
            // Get the plane's actual normal from its mesh orientation
            // PlaneGeometry default normal is (0, 0, 1) in local space
            const normal = new THREE.Vector3(0, 0, 1);
            
            // Apply the mesh's rotation to get the world-space normal
            normal.applyQuaternion(plane.mesh.quaternion);
            normal.normalize();
            
            // Apply positive/negative setting
            if (plane.positive) {
                normal.negate();
            }
            
            // Get plane center position from mesh
            const origin = plane.mesh.position.clone();
            
            // Calculate arrow length based on plane size (about 60% of the smaller dimension)
            const arrowLength = Math.min(plane.width, plane.height) * 0.6;
            
            // Create arrow color based on direction
            // Positive = Green, Negative = Red
            const arrowColor = plane.positive ? 0x00ff00 : 0xff0000;
            
            // Create the arrow helper
            normalArrow = new THREE.ArrowHelper(
                normal,           // direction
                origin,           // origin
                arrowLength,      // length
                arrowColor,       // color
                arrowLength * 0.3, // headLength (30% of arrow length)
                arrowLength * 0.2  // headWidth (20% of arrow length)
            );
            
            // Make the arrow more visible
            normalArrow.line.material.linewidth = 3;
            
            // Add to scene
            scene.add(normalArrow);
            
            console.log(`✨ Normal arrow created and added to scene!`);
            console.log(`   Plane: "${plane.name}"`);
            console.log(`   Position: [${origin.x.toFixed(2)}, ${origin.y.toFixed(2)}, ${origin.z.toFixed(2)}]`);
            console.log(`   Direction: [${normal.x.toFixed(3)}, ${normal.y.toFixed(3)}, ${normal.z.toFixed(3)}]`);
            console.log(`   Color: ${plane.positive ? 'GREEN (positive)' : 'RED (negative)'}`);
            console.log(`   Arrow length: ${arrowLength.toFixed(2)}`);
            console.log(`   Scene children count: ${scene.children.length}`);
        }
        
        // Function to remove the normal arrow
        function removeNormalArrow() {
            if (normalArrow) {
                scene.remove(normalArrow);
                // ArrowHelper doesn't have dispose(), but we should clean up its children
                if (normalArrow.line) {
                    normalArrow.line.geometry.dispose();
                    normalArrow.line.material.dispose();
                }
                if (normalArrow.cone) {
                    normalArrow.cone.geometry.dispose();
                    normalArrow.cone.material.dispose();
                }
                normalArrow = null;
            }
        }

        let scalingcheck = false;
        let aspect = null;

        // 5. Handle image upload
        document.getElementById("imageInput").addEventListener("change", imageupload);

        let targetHeight = 10;

        function imageupload(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Check if file is an image (PNG, JPG, etc.)
            if (!file.type.match("image.*")) {
                alert("Please upload an image file (PNG, JPG, etc.)");
                return;
            }

            const reader = new FileReader();
            reader.onload = function (e) {
                const imageUrl = e.target.result;

                //to read the image dimension 
                const img = new Image();
                img.onload = function () {
                    aspect = img.width / img.height;
                    const targetHeight = 10;
                    const targetWidth = targetHeight * aspect;

                    imagePlane.geometry.dispose();
                    imagePlane.geometry = new THREE.PlaneGeometry(targetWidth, targetHeight);
                }
                const texture = new THREE.TextureLoader().load(imageUrl, function (texture) {
                    // Success: Apply texture to the plane
                    imagePlane.material.map = texture;
                    imagePlane.material.needsUpdate = true;
                    imagePlane.visible = true;
                    grid.visible = true; // Hide grid
                }, undefined, (error) => {
                    console.error("Error loading image:", error);
                    alert("Failed to load image. Try another file.");
                });
                img.src = imageUrl;
            };
            reader.onerror = (error) => {
                console.error("FileReader error:", error);
                alert("Error reading file. Try again.");
            };
            reader.readAsDataURL(file);
        }

        // Array to store all planes
        const planes = [];
        let selectedPlane = null;
        let gui = new dat.GUI();
        gui.domElement.classList.add("my-custom-gui");
        let transformControls = null;

        //new bit for scaling
        let isMeasuring = false;
        let measurePoints = [];

        function handleMeasurementClick(event) {
            if (!isMeasuring) return;

            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, cameras.top);

            // Check intersections with all scene objects (more reliable)
            const intersects = raycaster.intersectObject(imagePlane);
            let distance = null;

            if (intersects.length > 0) {
                const point = intersects[0].point;
                measurePoints.push(point);
                console.log(`Point ${measurePoints.length} recorded at:`, point);

                if (measurePoints.length === 2) {
                    distance = measurePoints[0].distanceTo(measurePoints[1]);
                    console.log(`Distance between points: ${distance.toFixed(2)} units`);

                    cleanupMeasurement();
                }
            }
            return distance;
        }

        function cleanupMeasurement() {
            measurePoints = [];
            isMeasuring = false;
            renderer.domElement.removeEventListener('click', handleMeasurementClick);
        }

        function handleScalingClick(event) {
            scalingdist = handleMeasurementClick(event);
        }

        let scalingdist = null;
        document.getElementById("scalingbutton").addEventListener("click", function () {
            setView(cameras.top);
            isMeasuring = true;
            scalingcheck = true;
            measurePoints = [];
            console.log("Ready to measure - click two points in the scene");

            // Add temporary click listener
            renderer.domElement.removeEventListener('click', handleScalingClick);
            renderer.domElement.addEventListener('click', handleScalingClick);
        });

        document.getElementById("updatescale").addEventListener("click", function () {
            const inputvalue = document.getElementById("scalinginput").value;
            if (!inputvalue) {
                alert("please key in the scale first")
            }
            else {
                updatemeasureplane(inputvalue);
            }
        })

        function updatemeasureplane(input) {
            if (!scalingdist || !aspect) {
                console.error("Measurement data not available");
                return;
            }

            // Calculate scaling factor
            let scalingfactor = input / scalingdist;
            const newtargetHeight = targetHeight * scalingfactor;
            const newtargetWidth = newtargetHeight * aspect;

            targetHeight = newtargetHeight;

            // Preserve current material and visibility
            const currentMaterial = imagePlane.material;
            const currentVisibility = imagePlane.visible;
            const currentPosition = imagePlane.position.clone();
            const currentRotation = imagePlane.rotation.clone();

            // Dispose old geometry and create new one
            imagePlane.geometry.dispose();
            imagePlane.geometry = new THREE.PlaneGeometry(newtargetWidth, newtargetHeight);

            // Restore properties
            imagePlane.material = currentMaterial;
            imagePlane.visible = currentVisibility;
            imagePlane.position.copy(currentPosition);
            imagePlane.rotation.copy(currentRotation);

            console.log("Plane updated with new dimensions:", newtargetWidth, newtargetHeight);
        }
        let nextId = 1;
        function generateId() {
            return nextId++;
        }

        // Function to create a new plane
        function createPlane(width = 1, height = 1) {
            const geometry = new THREE.PlaneGeometry(width, height);
            // Default to Receiver type with yellow color
            const defaultType = "Receiver";
            const defaultColorHex = 0xffff00;
            const material = new THREE.MeshStandardMaterial({
                color: defaultColorHex,
                side: THREE.DoubleSide,
                wireframe: false,
            });

            const plane = new THREE.Mesh(geometry, material);
            plane.position.set(0, 0, 0);
            plane.rotation.y = Math.PI * 2;
            plane.scale.set(1, 1, 1);
            const defaultName = `Plane ${planes.length + 1}`;
            // Store plane data
            const planeData = {
                id: generateId(),
                mesh: plane,
                width: width,
                height: height,
                // Store default values
                defaultWidth: width,
                defaultHeight: height,
                defaultX: 0,
                defaultY: height / 2,
                defaultZ: 0,
                defaultAngle: 0,
                defaultColor: material.color.getHex(),
                name: defaultName,
                x: plane.position.x,
                y: plane.position.y,
                z: plane.position.z,
                angle: plane.rotation.y * 180 / Math.PI,
                incline: plane.rotation.x * 180 / Math.PI,
                color: material.color.getHex(),
                temperature: 0,
                type: defaultType,
                positive: true
            };

            planes.push(planeData);
            scene.add(plane);

            // Make plane selectable
            plane.userData = planeData;
            if (history.length === 0) {
                initializeHistory();
            }
            captureState("Plane created");
            return planeData;

        }

        function resetPlaneToDefault() {
            if (selectedPlanes.length === 0) {
                alert("Please select at least one plane first");
                return;
            }

            captureState("Before reset");

            if (selectedPlaneGroup) {
                ungroupPlanes();
            }

            selectedPlanes.forEach(planeData => {
                // Reset all properties to defaults
                planeData.width = 1;
                planeData.height = 1;
                planeData.x = 0;
                planeData.y = 0.5;
                planeData.z = 0;
                planeData.angle = 0;
                planeData.incline = 0; // Reset incline to 0
                planeData.color = planeData.defaultColor;

                // Update the mesh
                planeData.mesh.geometry.dispose();
                planeData.mesh.geometry = new THREE.PlaneGeometry(
                    planeData.width,
                    planeData.height
                );

                planeData.mesh.position.set(
                    planeData.x,
                    planeData.y,
                    planeData.z
                );
                planeData.mesh.rotation.set(
                    planeData.incline * Math.PI / 180, // x rotation (incline)
                    planeData.angle * Math.PI / 180,   // y rotation (angle)
                    0                                  // z rotation
                );
                planeData.mesh.scale.set(1, 1, 1);
                planeData.mesh.material.color.setHex(planeData.color);
            });

            // Update the GUI
            if (selectedPlanes.length > 0) {
                updateGUI(selectedPlanes[selectedPlanes.length - 1]);
            }

        }

        // Add event listener for the reset button
        document.getElementById("resetPlane").addEventListener("click", resetPlaneToDefault);

        // Function to make plane stand on ground (bottom edge at y=0)
        function standPlaneOnGround() {
            if (selectedPlanes.length === 0) {
                alert("Please select at least one plane first");
                return;
            }

            captureState("Before stand");

            selectedPlanes.forEach(planeData => {
                // Calculate the 4 corners of the plane in local space
                const halfWidth = planeData.width / 2;
                const halfHeight = planeData.height / 2;
                
                const corners = [
                    new THREE.Vector3(-halfWidth, -halfHeight, 0),
                    new THREE.Vector3(halfWidth, -halfHeight, 0),
                    new THREE.Vector3(halfWidth, halfHeight, 0),
                    new THREE.Vector3(-halfWidth, halfHeight, 0)
                ];
                
                // Transform corners to world space
                const worldCorners = corners.map(corner => {
                    const worldCorner = corner.clone();
                    worldCorner.applyQuaternion(planeData.mesh.quaternion);
                    worldCorner.add(planeData.mesh.position);
                    return worldCorner;
                });
                
                // Find the minimum Y value (lowest point)
                const minY = Math.min(...worldCorners.map(c => c.y));
                
                // Calculate the offset needed to bring lowest point to y=0
                const yOffset = -minY;
                
                // Apply the offset to the plane's position
                planeData.mesh.position.y += yOffset;
                planeData.y = planeData.mesh.position.y;
                
                console.log(`📐 Plane "${planeData.name}" stood on ground: minY was ${minY.toFixed(3)}, adjusted by ${yOffset.toFixed(3)}, new Y: ${planeData.y.toFixed(3)}`);
            });

            // Update the GUI
            if (selectedPlanes.length > 0) {
                updateGUI(selectedPlanes[selectedPlanes.length - 1]);
                
                // Update normal arrow visualization if enabled
                if (showNormalArrow && selectedPlanes[selectedPlanes.length - 1].type === "Receiver") {
                    visualizeNormal(selectedPlanes[selectedPlanes.length - 1]);
                }
            }

            captureState("After stand");
        }

        // Add event listener for the stand button
        document.getElementById("standPlane").addEventListener("click", standPlaneOnGround);

        function deleteplanefn() {
            if (selectedPlanes.length === 0) return;

            captureState("Before delete");

            // Filter out planes that no longer exist in the scene
            const validSelectedPlanes = selectedPlanes.filter(planeData => {
                return planes.includes(planeData) && scene.children.includes(planeData.mesh);
            });

            if (validSelectedPlanes.length === 0) {
                console.warn('No valid planes to delete');
                selectedPlanes = [];
                return;
            }

            // Delete all valid selected planes
            validSelectedPlanes.forEach(planeData => {
                // Detach transform controls if they're attached to this plane or its group
                if (transformControlss.object === planeData.mesh || 
                    (selectedPlaneGroup && transformControlss.object === selectedPlaneGroup)) {
                    transformControlss.detach();
                }

                // Remove the actual plane mesh from scene
                scene.remove(planeData.mesh);

                // Remove top view line if it exists
                if (planeData.mesh.userData.topViewLine) {
                    scene.remove(planeData.mesh.userData.topViewLine);
                    planeData.mesh.userData.topViewLine = null;
                }

                const index = planes.indexOf(planeData);
                if (index > -1) {
                    planes.splice(index, 1);
                }

                planeData.mesh.geometry.dispose();
                planeData.mesh.material.dispose();
            });

            // Clear group if it exists
            if (selectedPlaneGroup) {
                scene.remove(selectedPlaneGroup);
                selectedPlaneGroup = null;
                originalPositions.clear();
            }

            gui.destroy();
            gui = new dat.GUI();
            selectedPlanes = [];
            removeNormalArrow(); // Remove arrow when planes are deleted
            captureState();
        }

        document.getElementById("deleteplane").addEventListener("click", deleteplanefn);

        // Function to update GUI for selected plane
        function updateGUI(planeData) {
            gui.destroy();
            gui = new dat.GUI();

            const nameController = gui.add(planeData, 'name').name('Name');
            nameController.onChange(function (newName) {
                // Trim whitespace
                newName = newName.trim();
                
                // Check for empty name
                if (!newName) {
                    alert('Name cannot be empty! Please provide a valid name.');
                    nameController.setValue(planeData.name);
                    return;
                }
                
                // Check for duplicate names
                const nameExists = planes.some(p => p !== planeData && p.name === newName);
                if (nameExists) {
                    alert(`This name already exists! Please choose a different name.\n\nExisting planes: ${planes.map(p => p.name).join(', ')}`);
                    nameController.setValue(planeData.name);
                    return;
                }
                
                console.log(`Plane renamed: "${planeData.name}" → "${newName}"`);
                planeData.name = newName;
                captureState();
            });

            // Add controllers with explicit state capture
            const controllers = {
                width: gui.add(planeData, 'width').name('Width').step(0.1),
                height: gui.add(planeData, 'height').name('Height').step(0.1),
                x: gui.add(planeData, 'x').name('X-position').step(0.1),
                y: gui.add(planeData, 'y').name('Y-position').step(0.01),
                z: gui.add(planeData, 'z').name('Z-position').step(0.1),
                angle: gui.add(planeData, 'angle', -180, 180).name('Rotation').step(1),
                incline: gui.add(planeData, 'incline', -180, 180).name("Inclination").step(1),
                temp: gui.add(planeData, "temperature").name("Heat Flux"),
                type: gui.add(planeData, "type", ["Receiver", "Emitter", "Inert"]).name("Type"),
                positive: gui.add(planeData, "positive").name("Normal Direction -"),
            };

            // Track previous values
            controllers.width.__oldValue = planeData.width;
            controllers.height.__oldValue = planeData.height;

            // Single onChange handler for all properties
            function handleGUIChange() {
                // Handle geometry changes
                if (controllers.width.__oldValue !== planeData.width ||
                    controllers.height.__oldValue !== planeData.height) {

                    planeData.defaultWidth = planeData.width;
                    planeData.defaultHeight = planeData.height;

                    planeData.mesh.geometry.dispose();
                    planeData.mesh.geometry = new THREE.PlaneGeometry(
                        planeData.width,
                        planeData.height
                    );

                    planeData.mesh.scale.set(1, 1, 1);

                    controllers.width.__oldValue = planeData.width;
                    controllers.height.__oldValue = planeData.height;
                    
                    // Update top view line if in top view
                    if (activeCamera === cameras.top) {
                        updateTopViewLine(planeData);
                    }
                }

                // Update position and rotation
                planeData.mesh.position.set(planeData.x, planeData.y, planeData.z);
                planeData.mesh.rotation.set(
                    planeData.incline * Math.PI / 180,
                    planeData.angle * Math.PI / 180,
                    0
                );

                // Update top view line if in top view and position/rotation changed
                if (activeCamera === cameras.top) {
                    updateTopViewLine(planeData);
                }

                // Ensure temperature control reflects current type
                updateTemperatureControl();
                
                // Update normal arrow visualization for receiver planes
                if (planeData.type === "Receiver") {
                    visualizeNormal(planeData);
                }

                // Always capture state after any change
                captureState();
            }

            // Add listeners to all controllers
            Object.values(controllers).forEach(controller => {
                if (controller.onChange) {
                    controller.onChange(handleGUIChange);
                }
            });

            // Helper to enable/disable a GUI controller input element
            function setControllerDisabled(controller, disabled) {
                if (!controller || !controller.domElement) return;
                const inputEl = controller.domElement.querySelector('input');
                if (inputEl) inputEl.disabled = disabled;
            }

            // Enable temp only for Emitters; otherwise set to 0 and disable
            function updateTemperatureControl() {
                const isEmitter = String(planeData.type || '').toLowerCase() === 'emitter';
                if (!isEmitter) {
                    if (planeData.temperature !== 0) {
                        planeData.temperature = 0;
                        controllers.temp.updateDisplay();
                        // Capture only when value actually changed
                        captureState();
                    }
                    setControllerDisabled(controllers.temp, true);
                } else {
                    setControllerDisabled(controllers.temp, false);
                }
            }

            // Update color by type, preserving selection highlight
            function updateColorByType() {
                const typeLower = String(planeData.type || '').toLowerCase();
                let hex = 0xffff00; // receiver default (yellow)
                if (typeLower === 'emitter') {
                    hex = 0xff0000; // emitter red
                } else if (typeLower === 'inert') {
                    hex = 0x0000ff; // inert blue
                }
                planeData.color = hex;
                // If currently selected, keep highlight (yellow), otherwise set mapped color
                planeData.mesh.material.color.setHex(selectedPlanes.includes(planeData) ? 0xe3e3e3 : hex);
                
                // Update top view line color if in top view
                updateTopViewLineColor(planeData, hex);
            }

            // React immediately to Type changes
            controllers.type.onChange(function () {
                updateTemperatureControl();
                updateColorByType();
                
                // Update or remove normal arrow based on type
                if (planeData.type === "Receiver") {
                    visualizeNormal(planeData);
                } else {
                    removeNormalArrow();
                }
                
                captureState();
            });
            
            // React to Normal Direction changes
            controllers.positive.onChange(function () {
                console.log(`Normal direction changed for "${planeData.name}": ${planeData.positive ? 'Positive (+)' : 'Negative (-)'}`);
                if (planeData.type === "Receiver" && planeData.contourData) {
                    console.warn(`⚠️ Normal direction changed after calculation. You may need to recalculate for accurate results.`);
                }
                
                // Update the normal arrow visualization
                if (planeData.type === "Receiver") {
                    visualizeNormal(planeData);
                }
                
                captureState();
            });

            // Initialize temperature control state on GUI creation
            updateTemperatureControl();
            updateColorByType();
            
            // Visualize the normal direction for receiver planes
            if (planeData.type === "Receiver") {
                visualizeNormal(planeData);
            } else {
                removeNormalArrow();
            }
        }


        renderer.domElement.addEventListener('click', (event) => {
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, activeCamera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            // Clear previous group if not holding shift and clicking empty space
            if (!isShiftPressed && selectedPlaneGroup && intersects.length === 0) {
                ungroupPlanes();
                return;
            }

            for (let i = 0; i < intersects.length; i++) {
                const object = intersects[i].object;

                // Check if clicked on a top view line
                if (object.userData && object.userData.parentPlane) {
                    const planeData = object.userData.parentPlane;
                    
                    // Ensure the plane still exists in the planes array
                    if (!planes.includes(planeData)) {
                        console.warn('Top view line references a plane that no longer exists');
                        return;
                    }
                    
                    if (isShiftPressed) {
                        // Shift+click - toggle selection
                        const index = selectedPlanes.indexOf(planeData);
                        if (index === -1) {
                            // Add to selection
                            selectedPlanes.push(planeData);
                            planeData.mesh.material.color.setHex(0xe3e3e3);
                            updateTopViewLineColor(planeData, 0xe3e3e3);

                            // If we have multiple planes selected, create/update group
                            if (selectedPlanes.length > 1) {
                                createOrUpdateGroup();
                            }
                        } else {
                            // Remove from selection
                            selectedPlanes.splice(index, 1);
                            planeData.mesh.material.color.setHex(planeData.color);
                            updateTopViewLineColor(planeData, planeData.color);

                            // If the plane is in a group, restore its parent and position
                            if (selectedPlaneGroup && planeData.mesh.parent === selectedPlaneGroup) {
                                const original = originalPositions.get(planeData);
                                selectedPlaneGroup.remove(planeData.mesh);
                                if (original) {
                                    original.parent.add(planeData.mesh);
                                    planeData.mesh.position.copy(original.worldPosition);
                                }
                                planeData.mesh.visible = true;
                            }

                            // Update group if we still have multiple planes
                            if (selectedPlanes.length > 1) {
                                createOrUpdateGroup();
                            } else {
                                // If only one plane left, disband group and restore visibility for all
                                ungroupPlanes();
                                planes.forEach(p => p.mesh.visible = true);
                            }
                        }
                    } else {
                        // Regular click - single selection
                        // Check if this plane is already the only selected plane
                        if (selectedPlanes.length === 1 && selectedPlanes[0] === planeData) {
                            // If clicking on the only selected plane, deselect it
                            selectedPlanes = [];
                            planeData.mesh.material.color.setHex(planeData.color);
                            updateTopViewLineColor(planeData, planeData.color);
                            ungroupPlanes();
                        } else {
                            // Otherwise, select this plane as the only selection
                            ungroupPlanes();
                            planes.forEach(p => {
                    p.mesh.material.color.setHex(p.color);
                    updateTopViewLineColor(p, p.color);
                });
                            planes.forEach(p => p.mesh.visible = true);
                            selectedPlanes = [planeData];
                            planeData.mesh.material.color.setHex(0xe3e3e3);
                            updateTopViewLineColor(planeData, 0xe3e3e3);
                        }
                    }

                    // Update transform controls
                    updateTransformControls();
                    return;
                }

                // Find the plane data (might be a child of the group)
                let planeData = null;
                if (object.userData && planes.some(p => p.mesh === object)) {
                    planeData = object.userData;
                } else if (object.parent && object.parent.userData && planes.some(p => p.mesh === object.parent)) {
                    planeData = object.parent.userData;
                }

                if (planeData) {
                    if (isShiftPressed) {
                        // Shift+click - toggle selection
                        const index = selectedPlanes.indexOf(planeData);
                        if (index === -1) {
                            // Add to selection
                            selectedPlanes.push(planeData);
                            planeData.mesh.material.color.setHex(0xe3e3e3);
                            updateTopViewLineColor(planeData, 0xe3e3e3);

                            // If we have multiple planes selected, create/update group
                            if (selectedPlanes.length > 1) {
                                createOrUpdateGroup();
                            }
                        } else {
                            // Remove from selection
                            selectedPlanes.splice(index, 1);
                            planeData.mesh.material.color.setHex(planeData.color);
                            updateTopViewLineColor(planeData, planeData.color);

                            // If the plane is in a group, restore its parent and position
                            if (selectedPlaneGroup && planeData.mesh.parent === selectedPlaneGroup) {
                                const original = originalPositions.get(planeData);
                                selectedPlaneGroup.remove(planeData.mesh);
                                if (original) {
                                    original.parent.add(planeData.mesh);
                                    planeData.mesh.position.copy(original.worldPosition);
                                }
                                planeData.mesh.visible = true;
                            }

                            // Update group if we still have multiple planes
                            if (selectedPlanes.length > 1) {
                                createOrUpdateGroup();
                            } else {
                                // If only one plane left, disband group and restore visibility for all
                                ungroupPlanes();
                                planes.forEach(p => p.mesh.visible = true);
                            }
                        }
                    } else {
                        // Regular click - single selection
                        // Check if this plane is already the only selected plane
                        if (selectedPlanes.length === 1 && selectedPlanes[0] === planeData) {
                            // If clicking on the only selected plane, deselect it
                            selectedPlanes = [];
                            planeData.mesh.material.color.setHex(planeData.color);
                            updateTopViewLineColor(planeData, planeData.color);
                            ungroupPlanes();
                        } else {
                            // Otherwise, select this plane as the only selection
                            ungroupPlanes();
                            planes.forEach(p => {
                    p.mesh.material.color.setHex(p.color);
                    updateTopViewLineColor(p, p.color);
                });
                            planes.forEach(p => p.mesh.visible = true);
                            selectedPlanes = [planeData];
                            planeData.mesh.material.color.setHex(0xe3e3e3);
                            updateTopViewLineColor(planeData, 0xe3e3e3);
                        }
                    }

                    // Update transform controls
                    updateTransformControls();
                    return;
                }
            }

            // Clicked on empty space without shift - clear selection
            if (!isShiftPressed) {
                ungroupPlanes();
                planes.forEach(p => {
                    p.mesh.material.color.setHex(p.color);
                    updateTopViewLineColor(p, p.color);
                });
                selectedPlanes = [];
                transformControlss.detach();
                gui.destroy();
                gui = new dat.GUI();
                removeNormalArrow(); // Remove arrow when nothing is selected
            }
        });

        function updateTransformControls() {
            if (selectedPlanes.length === 0) {
                // Only detach if transform controls are currently attached to something
                if (transformControlss.object) {
                    transformControlss.detach();
                }
                gui.destroy();
                gui = new dat.GUI();
                removeNormalArrow(); // Remove arrow when no planes selected
            } else if (selectedPlaneGroup) {
                // Control the group if we have one
                transformControlss.attach(selectedPlaneGroup);
                updateGUI(selectedPlanes[selectedPlanes.length - 1]);
            } else {
                // Control the last selected plane - ensure the mesh exists
                const targetMesh = selectedPlanes[selectedPlanes.length - 1].mesh;
                if (targetMesh && scene.children.includes(targetMesh)) {
                    transformControlss.attach(targetMesh);
                    updateGUI(selectedPlanes[selectedPlanes.length - 1]);
                } else {
                    // If mesh doesn't exist, detach and clear selection
                    transformControlss.detach();
                    selectedPlanes = [];
                    gui.destroy();
                    gui = new dat.GUI();
                }
            }
            
            // Configure transform controls based on mode and view
            if (transformControlss.getMode() === 'rotate') {
                // Always disable Z rotation and show only X and Y
                transformControlss.showX = true;
                transformControlss.showY = true;
                transformControlss.showZ = false;
            } else if (activeCamera === cameras.top) {
                // In top view, disable Y scaling (thickness)
                transformControlss.showX = true;
                transformControlss.showY = false;
                transformControlss.showZ = true;
            } else {
                // Default: show all axes for translate and scale
                transformControlss.showX = true;
                transformControlss.showY = true;
                transformControlss.showZ = true;
            }
        }
        function createOrUpdateGroup() {
            // If no group exists, create one
            if (!selectedPlaneGroup) {
                selectedPlaneGroup = new THREE.Group();
                scene.add(selectedPlaneGroup);

                // Store original positions and parents
                originalPositions = new Map();
                selectedPlanes.forEach(plane => {
                    // Store the world position and original parent
                    const worldPos = plane.mesh.getWorldPosition(new THREE.Vector3());
                    originalPositions.set(plane, {
                        worldPosition: worldPos.clone(),
                        parent: plane.mesh.parent
                    });

                    // Calculate local position relative to group center
                    const center = calculateGroupCenter();
                    plane.mesh.position.copy(worldPos).sub(center);

                    // Add to group
                    selectedPlaneGroup.add(plane.mesh);
                });

                // Position group at center
                const center = calculateGroupCenter();
                selectedPlaneGroup.position.copy(center);
            } else {
                // For existing group, just add any new planes
                selectedPlanes.forEach(plane => {
                    if (plane.mesh.parent !== selectedPlaneGroup) {
                        const worldPos = plane.mesh.getWorldPosition(new THREE.Vector3());
                        originalPositions.set(plane, {
                            worldPosition: worldPos.clone(),
                            parent: plane.mesh.parent
                        });

                        const center = selectedPlaneGroup.position;
                        plane.mesh.position.copy(worldPos).sub(center);
                        selectedPlaneGroup.add(plane.mesh);
                    }
                });
            }
            // Don't capture state when creating/updating groups - only capture when the group is actually transformed
        }

        function calculateGroupCenter() {
            const center = new THREE.Vector3();
            selectedPlanes.forEach(plane => {
                if (originalPositions.has(plane)) {
                    center.add(originalPositions.get(plane).worldPosition);
                } else {
                    center.add(plane.mesh.getWorldPosition(new THREE.Vector3()));
                }
            });
            center.divideScalar(selectedPlanes.length);
            return center;
        }

        function ungroupPlanes() {
            if (!selectedPlaneGroup) return;

            // Restore planes to their original positions and parents
            selectedPlanes.forEach(plane => {
                const original = originalPositions.get(plane);
                if (original) {
                    // Remove from group first
                    selectedPlaneGroup.remove(plane.mesh);

                    // Add back to original parent (usually the scene)
                    original.parent.add(plane.mesh);

                    // Restore world position
                    plane.mesh.position.copy(original.worldPosition);

                    // Update plane data to match world position
                    plane.x = plane.mesh.position.x;
                    plane.y = plane.mesh.position.y;
                    plane.z = plane.mesh.position.z;
                }
            });

            // Clean up the group
            scene.remove(selectedPlaneGroup);
            selectedPlaneGroup = null;
            originalPositions.clear();

            // Update GUI to reflect changes
            if (selectedPlanes.length > 0) {
                updateGUI(selectedPlanes[selectedPlanes.length - 1]);
            }
            // Don't capture state when ungrouping - the visual state doesn't change
        }


        // Dragging variables
        let isDragging = false;
        let activeAxis = null;
        let dragPlane = new THREE.Plane();
        let dragOffset = new THREE.Vector3();
        let state_control = false;
        const raycaster1 = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        let transformControlss = null;

        // Initialize transform controls
        function initTransformControls() {
            transformControlss = new THREE.TransformControls(activeCamera, renderer.domElement);
            transformControlss.setSpace('local');
            transformControlss.setMode('translate');
            transformControlss.size = 0.5;
            transformControlss.setTranslationSnap(0.01);  // Snap translation to 0.1 units
            transformControlss.setRotationSnap(Math.PI / 180); // Snap rotation to 10 degrees
            transformControlss.setScaleSnap(0.1); // Snap scaling to 0.05 units (5% increments)

            transformControlss.showX = true;
            transformControlss.showY = true;
            transformControlss.showZ = true;
            scene.add(transformControlss);

            // Disable orbit controls when transforming
            transformControlss.addEventListener('dragging-changed', function (event) {
                controls.enabled = !event.value;
                // When dragging starts, record the group's start position
                if (event.value && selectedPlaneGroup && transformControlss.object === selectedPlaneGroup) {
                    groupDragStartPosition = selectedPlaneGroup.position.clone();
                }
                // When dragging ends (event.value === false)
                if (!event.value) {
                    if (selectedPlaneGroup && transformControlss.object === selectedPlaneGroup) {
                        // Commit the group transformation to individual planes
                        commitGroupTransform();
                    } else {
                        // Capture state for individual plane transformations
                        captureState("Transform drag ended");
                    }
                }
            });

            transformControlss.addEventListener('objectChange', function () {
                // Apply grid snapping based on current transform mode
                applyGridSnapping();

                if (selectedPlaneGroup && transformControlss.object === selectedPlaneGroup) {
                    // Update all planes when group moves
                    selectedPlanes.forEach(plane => {
                        plane.x = plane.mesh.position.x + selectedPlaneGroup.position.x;
                        plane.y = plane.mesh.position.y + selectedPlaneGroup.position.y;
                        plane.z = plane.mesh.position.z + selectedPlaneGroup.position.z;
                        
                        // Update top view line if in top view
                        if (activeCamera === cameras.top) {
                            updateTopViewLine(plane);
                        }
                    });
                } else if (selectedPlanes.length > 0 &&
                    transformControlss.object === selectedPlanes[selectedPlanes.length - 1].mesh) {
                    updatePlaneDataFromTransform();
                    
                    // Update top view line if in top view
                    if (activeCamera === cameras.top) {
                        updateTopViewLine(selectedPlanes[selectedPlanes.length - 1]);
                    }
                }
                if (selectedPlanes.length > 0) {
                    updateGUI(selectedPlanes[selectedPlanes.length - 1]);
                }
            });
        }

        // Grid snapping implementation
        function applyGridSnapping() {
            if (!transformControlss.object) return;

            const currentMode = transformControlss.getMode();
            const object = transformControlss.object;

            // Get world position for proper grid alignment
            const worldPosition = new THREE.Vector3();
            object.getWorldPosition(worldPosition);

            switch (currentMode) {
                case 'translate':
                    if (gridSnapConfig.translation.enabled) {
                        // Snap world position to grid
                        const snappedWorldPos = new THREE.Vector3(
                            snapToGrid(worldPosition.x, gridSnapConfig.translation.size),
                            snapToGrid(worldPosition.y, gridSnapConfig.translation.size),
                            snapToGrid(worldPosition.z, gridSnapConfig.translation.size)
                        );

                        // Convert back to local position if object has a parent
                        if (object.parent && object.parent !== scene) {
                            const localPosition = new THREE.Vector3();
                            localPosition.copy(snappedWorldPos);
                            object.parent.worldToLocal(localPosition);
                            object.position.copy(localPosition);
                        } else {
                            object.position.copy(snappedWorldPos);
                        }
                    }
                    break;

                case 'rotate':
                    if (gridSnapConfig.rotation.enabled) {
                        // Snap rotation to increments
                        object.rotation.x = snapRotation(object.rotation.x, gridSnapConfig.rotation.increment);
                        object.rotation.y = snapRotation(object.rotation.y, gridSnapConfig.rotation.increment);
                        object.rotation.z = snapRotation(object.rotation.z, gridSnapConfig.rotation.increment);
                    }
                    break;

                case 'scale':
                    if (gridSnapConfig.scale.enabled) {
                        // Snap scale to increments with minimum
                        object.scale.x = snapScale(object.scale.x, gridSnapConfig.scale.increment, gridSnapConfig.scale.minScale);
                        object.scale.y = snapScale(object.scale.y, gridSnapConfig.scale.increment, gridSnapConfig.scale.minScale);
                        object.scale.z = snapScale(object.scale.z, gridSnapConfig.scale.increment, gridSnapConfig.scale.minScale);
                    }
                    break;
            }
        }

        function commitGroupTransform() {
            if (!selectedPlaneGroup || selectedPlanes.length === 0) return;

            // Calculate the total transformation
            const groupPosition = selectedPlaneGroup.position.clone();

            // Update each plane's world position
            selectedPlanes.forEach(plane => {
                // Calculate new world position
                const newWorldPos = new THREE.Vector3().addVectors(
                    plane.mesh.position,
                    groupPosition
                );

                // Update plane data
                plane.x = newWorldPos.x;
                plane.y = newWorldPos.y;
                plane.z = newWorldPos.z;

                // Update original positions (for future grouping)
                if (originalPositions.has(plane)) {
                    originalPositions.get(plane).worldPosition.copy(newWorldPos);
                }
            });

            // Reset group position to origin
            selectedPlaneGroup.position.set(0, 0, 0);

            // Update plane positions relative to the group (now at origin)
            selectedPlanes.forEach(plane => {
                plane.mesh.position.set(plane.x, plane.y, plane.z);
            });

            // Re-center the group
            updateGroupPosition();

            // Only capture state if the group was actually moved
            if (groupDragStartPosition && !groupDragStartPosition.equals(groupPosition)) {
                captureState();
            }
            groupDragStartPosition = null;
        }

        function updateGroupPosition() {
            if (!selectedPlaneGroup || selectedPlanes.length < 2) return;

            // Calculate center point in world space
            const center = new THREE.Vector3();
            selectedPlanes.forEach(plane => {
                if (originalPositions.has(plane)) {
                    center.add(originalPositions.get(plane).worldPosition);
                } else {
                    center.add(new THREE.Vector3(plane.x, plane.y, plane.z));
                }
            });
            center.divideScalar(selectedPlanes.length);

            // Update group position
            selectedPlaneGroup.position.copy(center);

            // Update plane positions relative to group
            selectedPlanes.forEach(plane => {
                const worldPos = originalPositions.has(plane) ?
                    originalPositions.get(plane).worldPosition.clone() :
                    new THREE.Vector3(plane.x, plane.y, plane.z);

                plane.mesh.position.copy(worldPos).sub(center);
            });
        }

        function updatePlaneDataFromTransform() {
            if (selectedPlanes.length === 0) return;

            const planeData = selectedPlanes[selectedPlanes.length - 1];
            const mesh = planeData.mesh;

            // Update position
            planeData.x = planeData.mesh.position.x;
            planeData.y = planeData.mesh.position.y;
            planeData.z = planeData.mesh.position.z;

            // Update rotation (convert to degrees)
            planeData.angle = Math.abs(mesh.rotation.y * (180 / Math.PI)) < 1e-10 ? 0 : mesh.rotation.y * (180 / Math.PI);
            planeData.incline = Math.abs(mesh.rotation.x * (180 / Math.PI)) < 1e-10 ? 0 : mesh.rotation.x * (180 / Math.PI);

            if (transformControlss.getMode() === 'scale') {
                planeData.width = planeData.defaultWidth * mesh.scale.x;
                planeData.height = planeData.defaultHeight * mesh.scale.y;
            }

            // Update the GUI to reflect changes
            updateGUI(planeData);
        }

        // Call this after setting up your scene
        initTransformControls();

        function restoration() {
            if (state_control) {
                controls.enabled = true;
                controls.update();
                state_control = false;
            }
        }
        window.addEventListener("mousedown", restoration);
        window.addEventListener('keydown', (event) => {
            if (!transformControlss) return;

            switch (event.key.toLowerCase()) {
                case 'w': // Translate
                    transformControlss.setMode('translate');
                    transformControlss.showZ = true;
                    break;
                case 'e': // Scale
                    transformControlss.setMode('scale');
                    transformControlss.showZ = true;
                    break;
                case 'r': // Rotate
                    transformControlss.setMode('rotate');
                    // Always disable Z rotation and show only X and Y
                    transformControlss.showX = true;
                    transformControlss.showY = true;
                    transformControlss.showZ = false;
                    break;
                case 'q': // Toggle between local and world space
                    if (transformControlss.space === 'local') {
                        transformControlss.setSpace('world');
                    } else {
                        transformControlss.setSpace('local');
                    }
                    break;
                case 'g': // Toggle grid snapping
                    gridSnapConfig.translation.enabled = !gridSnapConfig.translation.enabled;
                    gridSnapConfig.rotation.enabled = !gridSnapConfig.rotation.enabled;
                    gridSnapConfig.scale.enabled = !gridSnapConfig.scale.enabled;
                    console.log(`Grid snapping ${gridSnapConfig.translation.enabled ? 'enabled' : 'disabled'}`);
                    break;
                case 't': // Top view
                    setView(cameras.top);
                    console.log('Switched to top view');
                    break;
                case 'y': // Perspective view
                    setView(cameras.perspective);
                    console.log('Switched to perspective view');
                    break;
                case 'n': // Toggle normal arrow visualization
                    showNormalArrow = !showNormalArrow;
                    console.log(`Normal arrow visualization ${showNormalArrow ? 'ENABLED' : 'DISABLED'} (Press N to toggle)`);
                    
                    if (showNormalArrow) {
                        // Re-visualize if a receiver plane is selected
                        if (selectedPlanes.length > 0 && selectedPlanes[selectedPlanes.length - 1].type === "Receiver") {
                            visualizeNormal(selectedPlanes[selectedPlanes.length - 1]);
                        }
                    } else {
                        removeNormalArrow();
                    }
                    break;
                case 's': // Stand plane on ground
                    if (selectedPlanes.length > 0) {
                        standPlaneOnGround();
                    } else {
                        console.log('⚠️ No plane selected. Select a plane first to use Stand function (Press S)');
                    }
                    break;
            }
        });
        window.addEventListener("keydown", function (event) {
            if (event.key === "Delete") {
                deleteplanefn();
            }
        })

        // Add plane button
        const addplanebtn = document.getElementById("addplane");
        addplanebtn.addEventListener("click", function () {
            const newPlane = createPlane();
            updateGUI(newPlane);
            selectedPlane = newPlane;
            transformControlss.attach(newPlane.mesh);
        });


        // Export function
        document.getElementById('exportBtn').addEventListener('click', exportScene);

        function exportScene() {
            const sceneData = {
                version: '1.0',
                imagePlane: {
                    visible: imagePlane.visible,
                    position: imagePlane.position.toArray(),
                    rotation: imagePlane.rotation.toArray(),
                    scale: imagePlane.scale.toArray(),
                    geometry: {
                        width: imagePlane.geometry.parameters.width,
                        height: imagePlane.geometry.parameters.height
                    },
                    texture: imagePlane.material.map ? imagePlane.material.map.image.currentSrc : null
                },
                planes: planes.map(plane => ({
                    name: plane.name,
                    position: plane.mesh.position.toArray(),
                    rotation: plane.mesh.rotation.toArray(),
                    scale: [1, 1, 1],
                    width: plane.width,
                    height: plane.height,
                    color: plane.color,
                    temperature: plane.temperature,
                    type: plane.type,
                    // Include default values for proper import
                    defaultWidth: plane.defaultWidth,
                    defaultHeight: plane.defaultHeight,
                    // Include derived properties
                    x: plane.x,
                    y: plane.y,
                    z: plane.z,
                    angle: plane.angle,
                    incline: plane.incline
                })),
                scalingFactor: scalingdist ? {
                    measuredDistance: scalingDistance,
                    inputValue: document.getElementById('scalinginput').value
                } : null
            };

            const blob = new Blob([JSON.stringify(sceneData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = 'scene_export.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Import function
        // document.getElementById('importBtn').addEventListener('click', () => {
        //     document.getElementById('importFile').click();
        // });

        document.getElementById('importFile').addEventListener('change', importScene);

        function importScene(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const sceneData = JSON.parse(e.target.result);
                    loadSceneData(sceneData);
                } catch (error) {
                    console.error('Error parsing scene file:', error);
                    alert('Error loading scene file');
                }
            };
            reader.readAsText(file);
        }

        async function loadSceneData(sceneData) {
            // Clear existing scene
            while (planes.length) {
                deleteplanefn();
            }

            // Load image plane
            if (sceneData.imagePlane.texture) {
                await loadImageTexture(sceneData.imagePlane.texture);

                imagePlane.position.fromArray(sceneData.imagePlane.position);
                imagePlane.rotation.fromArray(sceneData.imagePlane.rotation);
                imagePlane.scale.fromArray(sceneData.imagePlane.scale);
                imagePlane.visible = sceneData.imagePlane.visible;

                // Update geometry
                imagePlane.geometry.dispose();
                imagePlane.geometry = new THREE.PlaneGeometry(
                    sceneData.imagePlane.geometry.width,
                    sceneData.imagePlane.geometry.height
                );
            }

            // Load planes
            sceneData.planes.forEach(planeData => {
                const newPlane = createPlane(planeData.width, planeData.height);
                newPlane.name = planeData.name || `Plane ${planes.length}`;

                // Update the default dimensions to match the imported dimensions
                newPlane.defaultWidth = planeData.width;
                newPlane.defaultHeight = planeData.height;

                // Set position and rotation
                newPlane.mesh.position.fromArray(planeData.position);
                newPlane.mesh.rotation.fromArray(planeData.rotation);

                // Handle scale properly - if scale is not 1,1,1, we need to adjust the actual dimensions
                if (planeData.scale && (planeData.scale[0] !== 1 || planeData.scale[1] !== 1)) {
                    // If there's a scale, apply it to the dimensions
                    newPlane.width = planeData.width * planeData.scale[0];
                    newPlane.height = planeData.height * planeData.scale[1];
                    // Reset scale to 1,1,1 since we've incorporated it into dimensions
                    newPlane.mesh.scale.set(1, 1, 1);
                } else {
                    // No scale or scale is 1,1,1, just use the imported dimensions
                    newPlane.width = planeData.width;
                    newPlane.height = planeData.height;
                    newPlane.mesh.scale.set(1, 1, 1);
                }

                // Update the mesh geometry to match the new dimensions
                newPlane.mesh.geometry.dispose();
                newPlane.mesh.geometry = new THREE.PlaneGeometry(newPlane.width, newPlane.height);

                // Set color and temperature
                newPlane.color = planeData.color;
                newPlane.mesh.material.color.setHex(planeData.color);
                if (planeData.temperature !== undefined) {
                    newPlane.temperature = planeData.temperature;
                }
                if (planeData.type !== undefined) {
                    newPlane.type = planeData.type;
                }
                if (planeData.positive !== undefined) {
                    newPlane.positive = planeData.positive;
                } else {
                    newPlane.positive = true; // Default to true for backward compatibility
                }
                // Update derived properties - use imported values if available, otherwise calculate from mesh
                if (planeData.x !== undefined) {
                    newPlane.x = planeData.x;
                } else {
                    newPlane.x = newPlane.mesh.position.x;
                }
                if (planeData.y !== undefined) {
                    newPlane.y = planeData.y;
                } else {
                    newPlane.y = newPlane.mesh.position.y;
                }
                if (planeData.z !== undefined) {
                    newPlane.z = planeData.z;
                } else {
                    newPlane.z = newPlane.mesh.position.z;
                }
                if (planeData.angle !== undefined) {
                    newPlane.angle = planeData.angle;
                } else {
                    newPlane.angle = newPlane.mesh.rotation.y * (180 / Math.PI);
                }
                if (planeData.incline !== undefined) {
                    newPlane.incline = planeData.incline;
                } else {
                    newPlane.incline = newPlane.mesh.rotation.x * (180 / Math.PI);
                }

                updateGUI(newPlane);

                // Force a geometry update to ensure the mesh size matches the stored dimensions
                if (newPlane.mesh.geometry) {
                    newPlane.mesh.geometry.dispose();
                }
                newPlane.mesh.geometry = new THREE.PlaneGeometry(newPlane.width, newPlane.height);

                // Debug logging
                console.log(`Imported plane "${newPlane.name}":`, {
                    width: newPlane.width,
                    height: newPlane.height,
                    defaultWidth: newPlane.defaultWidth,
                    defaultHeight: newPlane.defaultHeight,
                    scale: newPlane.mesh.scale.toArray(),
                    position: newPlane.mesh.position.toArray(),
                    geometry: {
                        width: newPlane.mesh.geometry.parameters.width,
                        height: newPlane.mesh.geometry.parameters.height
                    }
                });
            });

            // Load scaling data
            if (sceneData.scalingFactor) {
                scalingDistance = sceneData.scalingFactor.measuredDistance;
                document.getElementById('scalinginput').value = sceneData.scalingFactor.inputValue;
            }

            // Validate and fix any scaling issues
            planes.forEach(plane => {
                // Ensure the mesh geometry matches the stored dimensions
                const expectedWidth = plane.width;
                const expectedHeight = plane.height;
                const actualWidth = plane.mesh.geometry.parameters.width;
                const actualHeight = plane.mesh.geometry.parameters.height;

                if (Math.abs(expectedWidth - actualWidth) > 0.001 || Math.abs(expectedHeight - actualHeight) > 0.001) {
                    console.warn(`Fixing size mismatch for plane "${plane.name}":`, {
                        expected: { width: expectedWidth, height: expectedHeight },
                        actual: { width: actualWidth, height: actualHeight }
                    });

                    // Recreate geometry with correct dimensions
                    plane.mesh.geometry.dispose();
                    plane.mesh.geometry = new THREE.PlaneGeometry(expectedWidth, expectedHeight);

                    // Reset scale to 1,1,1
                    plane.mesh.scale.set(1, 1, 1);
                }
            });

            alert('Scene imported successfully!');
        }

        async function loadImageTexture(imageUrl) {
            return new Promise((resolve, reject) => {
                const textureLoader = new THREE.TextureLoader();
                textureLoader.load(imageUrl,
                    (texture) => {
                        imagePlane.material.map = texture;
                        imagePlane.material.needsUpdate = true;
                        imagePlane.visible = true;

                        // Update aspect ratio
                        const img = new Image();
                        img.onload = function () {
                            aspect = img.width / img.height;
                            resolve();
                        };
                        img.src = imageUrl;
                    },
                    undefined,
                    (error) => {
                        console.error('Error loading image:', error);
                        reject(error);
                    }
                );
            });
        }

        let dataarrayforcontour = null;
        // Receiver grid size (N x N), default 10
        let receiverGridSize = 10;
        // Backend endpoint for contour generation
        const BACKEND_CONTOUR_URL = CONFIG.BACKEND_URL + CONFIG.CALCULATE_ENDPOINT;
        
        // Color scale settings
        let colorScaleMin = 0;
        let colorScaleMax = 20;
        
        // Function to get color scale values from UI
        function getColorScaleValues() {
            const minInput = document.getElementById('colorScaleMin');
            const maxInput = document.getElementById('colorScaleMax');
            
            const min = parseFloat(minInput.value) || 0;
            const max = parseFloat(maxInput.value) || 20;
            
            // Ensure max > min
            if (max <= min) {
                console.warn('Max value must be greater than min value. Using defaults.');
                return { min: 0, max: 20 };
            }
            
            return { min, max };
        }
        
        // Function to create color legend
        function createColorLegend(minValue, maxValue, numTicks = 11, dataMin = null, dataMax = null) {
            const legendGradient = document.getElementById('legendGradient');
            const legendLabels = document.getElementById('legendLabels');
            const colorLegendDiv = document.getElementById('colorLegend');
            
            // Create gradient using d3 color scale
            const colorScale = d3.scaleSequential(d3.interpolateTurbo).domain([minValue, maxValue]);
            
            // Create CSS gradient
            const numStops = 100;
            let gradientStops = [];
            for (let i = 0; i <= numStops; i++) {
                const value = minValue + (maxValue - minValue) * (i / numStops);
                const color = colorScale(value);
                const percentage = (i / numStops) * 100;
                gradientStops.push(`${color} ${percentage}%`);
            }
            
            // Apply gradient (bottom to top, reversed because we want high values at top)
            legendGradient.style.background = `linear-gradient(to top, ${gradientStops.join(', ')})`;
            
            // Create labels
            legendLabels.innerHTML = '';
            const step = (maxValue - minValue) / (numTicks - 1);
            
            for (let i = 0; i < numTicks; i++) {
                const value = maxValue - (i * step); // Reverse order (high to low)
                const label = document.createElement('div');
                label.textContent = value.toFixed(2);
                label.style.fontWeight = 'bold';
                legendLabels.appendChild(label);
            }
            
            // Add data range info if provided
            let existingInfo = colorLegendDiv.querySelector('.data-range-info');
            if (existingInfo) {
                existingInfo.remove();
            }
            
            if (dataMin !== null && dataMax !== null) {
                const infoDiv = document.createElement('div');
                infoDiv.className = 'data-range-info';
                infoDiv.innerHTML = `
                    <strong>Actual Data Range:</strong>
                    Min: ${dataMin.toFixed(3)}<br>
                    Max: ${dataMax.toFixed(3)}
                    ${(dataMin < minValue || dataMax > maxValue) ? '<br><br><strong style="color: #d9534f;"> Data exceeds color scale!</strong>' : ''}
                `;
                colorLegendDiv.appendChild(infoDiv);
            }
        }

        // Generate smoother, more realistic fields for contours
        // Removed random generators; contours now rely on backend-provided data only

        // Holder for backend-provided contour data
        let uploadedContour = null; // { width, height, values }

        // Normalize various JSON formats into {width,height,values(flat array)}
        function normalizeContourJson(json) {
            // If already normalized
            if (json && Number.isInteger(json.width) && Number.isInteger(json.height) && Array.isArray(json.values)) {
                // If values are 2D, flatten
                if (Array.isArray(json.values[0])) {
                    const flat = [];
                    for (let y = 0; y < json.height; y++) {
                        for (let x = 0; x < json.width; x++) {
                            flat.push(json.values[y][x]);
                        }
                    }
                    return { width: json.width, height: json.height, values: flat };
                }
                return { width: json.width, height: json.height, values: json.values };
            }
            // If just a 2D array
            if (Array.isArray(json) && Array.isArray(json[0])) {
                const height = json.length;
                const width = json[0].length;
                const flat = [];
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) flat.push(json[y][x]);
                }
                return { width, height, values: flat };
            }
            // If just flat array, require square-ish detection is not reliable; reject
            throw new Error('Unsupported contour JSON format. Expected {width,height,values}, 2D array, or flat array with dims.');
        }

        // Note: uploadedContour should be set by backend integration code before invoking contour rendering

        function generateRbfField(n, m, options = {}) {
            const numSources = options.numSources || 5;
            const amplitudeMin = options.amplitudeMin ?? 2;
            const amplitudeMax = options.amplitudeMax ?? 10;
            const diag = Math.sqrt(n * n + m * m);
            const sigmaMin = options.sigmaMin ?? diag * 0.10;
            const sigmaMax = options.sigmaMax ?? diag * 0.35;
            const gradientStrength = options.gradientStrength ?? 0.15; // 0..1 small trend
            const noiseStd = options.noiseStd ?? 0.03; // relative to max amplitude

            const sources = [];
            for (let i = 0; i < numSources; i++) {
                sources.push({
                    cx: Math.random() * (n - 1),
                    cy: Math.random() * (m - 1),
                    amp: amplitudeMin + Math.random() * (amplitudeMax - amplitudeMin),
                    sigma: sigmaMin + Math.random() * (sigmaMax - sigmaMin)
                });
            }

            const values = new Array(n * m);
            let minV = Infinity, maxV = -Infinity;
            for (let y = 0; y < m; y++) {
                for (let x = 0; x < n; x++) {
                    let v = 0;
                    for (let k = 0; k < sources.length; k++) {
                        const dx = x - sources[k].cx;
                        const dy = y - sources[k].cy;
                        const r2 = dx * dx + dy * dy;
                        const sigma2 = 2 * sources[k].sigma * sources[k].sigma;
                        v += sources[k].amp * Math.exp(-r2 / sigma2);
                    }
                    // Add a gentle gradient/trend to avoid overly symmetric blobs
                    v += gradientStrength * (x / n * amplitudeMax * 0.5 + y / m * amplitudeMax * 0.5);
                    // Add a tiny amount of noise for texture
                    v += (Math.random() * 2 - 1) * noiseStd * amplitudeMax;
                    values[y * n + x] = v;
                    if (v < minV) minV = v;
                    if (v > maxV) maxV = v;
                }
            }
            // Normalize to a friendly range (e.g., 0..10)
            const range = maxV - minV || 1;
            for (let i = 0; i < values.length; i++) {
                values[i] = 10 * (values[i] - minV) / range;
            }
            return values;
        }

        function generateSinusoidalField(n, m, options = {}) {
            const A1 = options.A1 ?? 3, A2 = options.A2 ?? 2.5, A3 = options.A3 ?? 2;
            const fx1 = options.fx1 ?? (2 * Math.PI / (n * 0.9));
            const fy1 = options.fy1 ?? (2 * Math.PI / (m * 0.7));
            const fx2 = options.fx2 ?? (2 * Math.PI / (n * 0.35));
            const fy2 = options.fy2 ?? (2 * Math.PI / (m * 0.5));
            const p1 = options.p1 ?? Math.random() * Math.PI * 2;
            const p2 = options.p2 ?? Math.random() * Math.PI * 2;
            const p3 = options.p3 ?? Math.random() * Math.PI * 2;
            const baseline = options.baseline ?? 2.5;
            const noiseStd = options.noiseStd ?? 0.05;

            const values = new Array(n * m);
            let minV = Infinity, maxV = -Infinity;
            for (let y = 0; y < m; y++) {
                for (let x = 0; x < n; x++) {
                    let v = baseline
                        + A1 * Math.sin(fx1 * x + p1)
                        + A2 * Math.cos(fy1 * y + p2)
                        + A3 * Math.sin(fx2 * x + fy2 * y + p3)
                        + (Math.random() * 2 - 1) * noiseStd;
                    values[y * n + x] = v;
                    if (v < minV) minV = v;
                    if (v > maxV) maxV = v;
                }
            }
            const range = maxV - minV || 1;
            for (let i = 0; i < values.length; i++) {
                values[i] = 10 * (values[i] - minV) / range;
            }
            return values;
        }

        function generatePointsOnPlane(plane, rows = 11, cols = 11) {
            const points = [];
            const width = plane.width;
            const height = plane.height;

            // Calculate step sizes
            const xStep = width / (cols - 1);
            const yStep = height / (rows - 1);

            // Get the plane's world position and rotation
            const worldPosition = plane.mesh.position.clone();
            const worldQuaternion = plane.mesh.quaternion.clone();

            // Generate grid points
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    // Calculate local position (centered on plane)
                    // THREE.js PlaneGeometry lies in the XY plane with Z as the normal
                    const xLocal = (col * xStep) - (width / 2);
                    const yLocal = (row * yStep) - (height / 2);
                    const zLocal = 0; // On the plane surface (Z is perpendicular to plane)

                    // Create vector in local space
                    const point = new THREE.Vector3(xLocal, yLocal, zLocal);
                    
                    // Apply the mesh's rotation to transform from local to world space
                    point.applyQuaternion(worldQuaternion);
                    
                    // Add plane position offset
                    point.add(worldPosition);

                    points.push({
                        id: row * cols + col + 1,
                        position: {
                            x: parseFloat(point.x.toFixed(4)),
                            y: parseFloat(point.y.toFixed(4)),
                            z: parseFloat(point.z.toFixed(4))
                        },
                        localGrid: {
                            row: row + 1,
                            column: col + 1
                        }
                    });
                }
            }

            return points;
        }

        async function Pointsinfo() {
            // Show loading indicator
            const calculateBtn = document.getElementById('calculate');
            const originalText = calculateBtn.textContent;
            calculateBtn.textContent = 'Calculating...';
            calculateBtn.disabled = true;
            
            try {
                const receiver_planes = {};
                const polygons = [];
                const inert_polygons = [];

                // Helpers
                function computeWorldCorners(plane) {
                    const width = plane.width;
                    const height = plane.height;
                    const corners = [
                        new THREE.Vector3(-width/2, 0, -height/2),
                        new THREE.Vector3(width/2, 0, -height/2),
                        new THREE.Vector3(width/2, 0, height/2),
                        new THREE.Vector3(-width/2, 0, height/2)
                    ];
                    const makeHorizontal = new THREE.Matrix4().makeRotationX(-Math.PI / 2);
                    const rotationY = new THREE.Matrix4().makeRotationY(plane.angle * Math.PI / 180);
                    const rotationX = new THREE.Matrix4().makeRotationX(plane.incline * Math.PI / 180);
                    const rotationMatrix = new THREE.Matrix4()
                        .multiply(makeHorizontal)
                        .multiply(rotationX)
                        .multiply(rotationY);
                    return corners.map(corner => {
                        corner.applyMatrix4(rotationMatrix);
                        corner.add(new THREE.Vector3(plane.x, plane.y, plane.z));
                        return [
                            Math.round(corner.x * 100) / 100,
                            Math.round(corner.y * 100) / 100,
                            Math.round(corner.z * 100) / 100
                        ];
                    });
                }

                function computePlaneNormal(plane) {
                    // Get the plane's actual normal from its mesh orientation
                    // PlaneGeometry default normal is (0, 0, 1) in local space
                    const normal = new THREE.Vector3(0, 0, 1);
                    
                    // Apply the mesh's rotation to get the world-space normal
                    normal.applyQuaternion(plane.mesh.quaternion);
                    normal.normalize();
                    
                    console.log(`    Normal before positive/negative check: [${normal.x.toFixed(4)}, ${normal.y.toFixed(4)}, ${normal.z.toFixed(4)}], positive=${plane.positive}`);
                    
                    // Apply positive/negative setting
                    if (plane.positive) {
                        // If positive direction is desired, flip the normal
                        normal.negate();
                        console.log(`    Normal AFTER applying positive direction: [${normal.x.toFixed(4)}, ${normal.y.toFixed(4)}, ${normal.z.toFixed(4)}]`);
                    } else {
                        console.log(`    Normal kept as negative direction (no flip): [${normal.x.toFixed(4)}, ${normal.y.toFixed(4)}, ${normal.z.toFixed(4)}]`);
                    }
                    
                    // Return as array with high precision
                    return [
                        Math.round(normal.x * 10000) / 10000,
                        Math.round(normal.y * 10000) / 10000,
                        Math.round(normal.z * 10000) / 10000
                    ];
                }

                // Build structure
                // First, check for duplicate receiver plane names
                const receiverPlaneNames = new Set();
                const receiverPlanes = planes.filter(p => p.type === "Receiver");
                receiverPlanes.forEach(plane => {
                    if (receiverPlaneNames.has(plane.name)) {
                        alert(`Warning: Multiple receiver planes have the same name "${plane.name}". Please rename them to get accurate results.`);
                        console.error(`❌ DUPLICATE NAME DETECTED: "${plane.name}"`);
                    }
                    receiverPlaneNames.add(plane.name);
                });
                
                console.log(`=== Processing ${receiverPlanes.length} Receiver Plane(s) ===`);
                
                planes.forEach(plane => {
                    if (plane.type === "Receiver") {
                        // Calculate grid dimensions based on plane size and user input N
                        const N = Math.max(1, Math.min(50, parseInt(receiverGridSize, 10) || 10));
                        const roundedWidth = Math.ceil(plane.width);
                        const roundedHeight = Math.ceil(plane.height);
                        const gridWidth = roundedWidth * N;
                        const gridHeight = roundedHeight * N;
                        
                        console.log(`\n📊 Receiver plane "${plane.name}": original size ${plane.width}x${plane.height}, rounded to ${roundedWidth}x${roundedHeight}, grid size ${gridWidth}x${gridHeight}`);
                        
                        const points = generatePointsOnPlane(plane, gridHeight, gridWidth);
                        const normalArr = computePlaneNormal(plane);
                        
                        console.log(`  🔄 Plane "${plane.name}" - angle: ${plane.angle}°, incline: ${plane.incline}°, positive: ${plane.positive}`);
                        console.log(`  📍 Plane mesh position: [${plane.mesh.position.x.toFixed(2)}, ${plane.mesh.position.y.toFixed(2)}, ${plane.mesh.position.z.toFixed(2)}]`);
                        console.log(`  🔄 Plane mesh rotation (euler): [${(plane.mesh.rotation.x * 180/Math.PI).toFixed(2)}°, ${(plane.mesh.rotation.y * 180/Math.PI).toFixed(2)}°, ${(plane.mesh.rotation.z * 180/Math.PI).toFixed(2)}°]`);
                        console.log(`  ➡️  Computed normal: [${normalArr[0]}, ${normalArr[1]}, ${normalArr[2]}]`);
                        console.log(`  🎯 Sample point 0: [${points[0].position.x.toFixed(2)}, ${points[0].position.y.toFixed(2)}, ${points[0].position.z.toFixed(2)}]`);
                        console.log(`  🎯 Sample point ${points.length-1}: [${points[points.length-1].position.x.toFixed(2)}, ${points[points.length-1].position.y.toFixed(2)}, ${points[points.length-1].position.z.toFixed(2)}]`);
                        console.log(`  🎯 Total points generated: ${points.length}`);
                        
                        // Check if name already exists (shouldn't due to earlier check, but safety)
                        if (receiver_planes[plane.name]) {
                            console.error(`❌ OVERWRITING existing receiver plane data for "${plane.name}"!`);
                        }
                        
                        // Use the actual plane's name instead of generic plane1, plane2, etc.
                        receiver_planes[plane.name] = {
                            width: gridWidth,
                            height: gridHeight,
                            points: points.map(pt => ({
                                origin: [
                                    Math.round(pt.position.x * 100) / 100,
                                    Math.round(pt.position.y * 100) / 100,
                                    Math.round(pt.position.z * 100) / 100
                                ],
                                normal: normalArr
                            }))
                        };
                    } else if (plane.type === "Emitter") {
                        const worldCorners = computeWorldCorners(plane);
                        console.log(`Emitter "${plane.name}" - temperature: ${plane.temperature}`);
                        console.log(`  Position: [${plane.x}, ${plane.y}, ${plane.z}]`);
                        console.log(`  Corners:`, worldCorners);
                        polygons.push({ polygon: worldCorners, temperature: plane.temperature });
                    } else if (plane.type === "Inert") {
                        const worldCorners = computeWorldCorners(plane);
                        inert_polygons.push(worldCorners);
                    }
                });

                const exportData = {
                    receiver_planes: receiver_planes,
                    polygons: polygons,
                    inert_polygons: inert_polygons,
                    num_rays: 100000
                };

                // Log the complete JSON output
                console.log("=== COMPLETE JSON OUTPUT ===");
                console.log(JSON.stringify(exportData, null, 2));
                console.log("=== END JSON OUTPUT ===");
                
                // Also log a summary
                console.log(`JSON Summary: ${Object.keys(receiver_planes).length} receiver planes, ${polygons.length} emitter polygons, ${inert_polygons.length} inert polygons`);

                // Send to backend and await contour response
                console.log('Sending data to backend:', exportData);
                
                const resp = await fetch(BACKEND_CONTOUR_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(exportData)
                });
                
                if (!resp.ok) {
                    const errorText = await resp.text();
                    throw new Error(`Backend error: ${resp.status} - ${errorText}`);
                }
                
                const responseData = await resp.json();
                
                // Log the complete backend response
                console.log('=== BACKEND RESPONSE RECEIVED ===');
                console.log('Full JSON response:', JSON.stringify(responseData, null, 2));
                console.log('Number of planes in response:', responseData.planes ? responseData.planes.length : 0);
                if (responseData.planes) {
                    responseData.planes.forEach((plane, idx) => {
                        console.log(`  Plane ${idx + 1}: "${plane.name}" - ${plane.width}x${plane.height} grid, ${plane.values.length} values`);
                        console.log(`    Temperature range: ${Math.min(...plane.values).toFixed(2)} to ${Math.max(...plane.values).toFixed(2)}`);
                    });
                }
                console.log('=== END BACKEND RESPONSE ===');
                
                if (responseData.success && responseData.planes && Array.isArray(responseData.planes)) {
                    // Process multiple planes
                    let planesProcessed = 0;
                    let planesNotMatched = [];
                    
                    console.log(`\n=== Matching Backend Response to Receiver Planes ===`);
                    console.log(`Backend returned ${responseData.planes.length} plane(s)`);
                    console.log(`We have ${receiverPlanes.length} receiver plane(s) in scene`);
                    
                    responseData.planes.forEach(planeData => {
                        console.log(`\n🔍 Looking for plane with name: "${planeData.name}"`);
                        
                        // Find matching receiver plane by name
                        const matchingPlane = planes.find(p => 
                            p.type === "Receiver" && p.name === planeData.name
                        );
                        
                        if (matchingPlane) {
                            // Store contour data on the plane object
                            matchingPlane.contourData = {
                                width: planeData.width,
                                height: planeData.height,
                                values: planeData.values
                            };
                            
                            console.log(`✅ MATCHED! Contour data applied to receiver plane: ${matchingPlane.name}`);
                            console.log(`   Grid: ${planeData.width}x${planeData.height}, Values: ${planeData.values.length}`);
                            planesProcessed++;
                            
                            // Apply contour texture to the plane
                            applyContourTexture(matchingPlane);
                        } else {
                            console.error(`❌ NO MATCH FOUND for backend plane: "${planeData.name}"`);
                            console.log(`   Available receiver planes: ${receiverPlanes.map(p => `"${p.name}"`).join(', ')}`);
                            planesNotMatched.push(planeData.name);
                        }
                    });
                    
                    console.log(`\n=== Matching Complete ===`);
                    console.log(`✅ Successfully matched: ${planesProcessed}`);
                    console.log(`❌ Not matched: ${planesNotMatched.length}`);
                    
                    if (planesNotMatched.length > 0) {
                        alert(`Calculation complete!\n\nMatched: ${planesProcessed} plane(s)\nNot matched: ${planesNotMatched.length} plane(s) (${planesNotMatched.join(', ')})\n\nCheck console for details.`);
                    } else {
                        alert(`Calculation complete! Contour data applied to ${planesProcessed} receiver plane(s).`);
                    }
                } else {
                    throw new Error('Invalid response format from backend');
                }
            } catch (err) {
                console.error('Failed to fetch contour data:', err);
                alert(`Failed to fetch contour data from backend: ${err.message}`);
            } finally {
                // Restore button state
                calculateBtn.textContent = originalText;
                calculateBtn.disabled = false;
            }
        }

        document.getElementById("calculate").addEventListener("click", Pointsinfo);
        
        // Update receiver grid size from input
        const gridSizeEl = document.getElementById('gridSizeInput');
        if (gridSizeEl) {
            gridSizeEl.addEventListener('change', function () {
                const val = parseInt(this.value, 10);
                if (isNaN(val)) return;
                receiverGridSize = Math.max(1, Math.min(50, val));
            });
        }
        
        // Update color scale when inputs change and regenerate contours on existing data
        const colorScaleMinEl = document.getElementById('colorScaleMin');
        const colorScaleMaxEl = document.getElementById('colorScaleMax');
        
        function updateColorScale() {
            const { min, max } = getColorScaleValues();
            colorScaleMin = min;
            colorScaleMax = max;
            console.log(`Color scale updated: ${min} to ${max}`);
            
            // Regenerate contour textures for all planes that have contour data
            planes.forEach(plane => {
                if (plane.type === "Receiver" && plane.contourData) {
                    applyContourTexture(plane);
                }
            });
            
            // Show notification
            console.log('Contour colors updated for all receiver planes with data');
        }
        
        if (colorScaleMinEl) {
            colorScaleMinEl.addEventListener('change', updateColorScale);
        }
        
        if (colorScaleMaxEl) {
            colorScaleMaxEl.addEventListener('change', updateColorScale);
        }

        // Add this function to handle the contour generation
        // Removed addContourToSelectedPlane; use backend-provided data via detail modal

        let clipboard = null; // Will store copied planes
        let isCtrlPressed = false; // Track Ctrl key state
        // Add these near your other key listeners
        window.addEventListener('keydown', (event) => {
            if (event.key === 'Control') {
                isCtrlPressed = true;
            }
            // Add copy/paste shortcuts (Ctrl+C, Ctrl+V)
            if (isCtrlPressed && event.key === 'c') {
                copySelected();
            }
            if (isCtrlPressed && event.key === 'v') {
                pasteFromClipboard();
            }
        });

        window.addEventListener('keyup', (event) => {
            if (event.key === 'Control') {
                isCtrlPressed = false;
            }
        });

        function copySelected() {
            if (selectedPlanes.length === 0) return;

            clipboard = {
                isGroup: selectedPlaneGroup !== null,
                planes: selectedPlanes.map(plane => ({
                    width: plane.defaultWidth,
                    height: plane.defaultHeight,
                    position: plane.mesh.position.clone(),
                    rotation: plane.mesh.rotation.clone(),
                    scale: plane.mesh.scale.clone(),
                    color: plane.color,
                    temperature: plane.temperature,
                    type: plane.type,
                    positive: plane.positive
                })),
                relativePositions: selectedPlaneGroup ?
                    selectedPlanes.map(plane => plane.mesh.position.clone()) :
                    null
            };
            console.log('Copied selection to clipboard');
            captureState();
        }


        function pasteFromClipboard() {
            if (!clipboard) return;

            captureState("Before paste");

            // Clear current selection
            planes.forEach(p => p.mesh.material.color.setHex(p.color));
            selectedPlanes = [];
            if (selectedPlaneGroup) {
                ungroupPlanes();
            }

            // Create new planes from clipboard
            const newPlanes = [];
            const offset = new THREE.Vector3(1, 0, 1); // Small offset for pasted copies

            clipboard.planes.forEach((planeData, index) => {
                const newPlane = createPlane(planeData.width, planeData.height);

                // Set properties from copied plane
                newPlane.mesh.position.copy(planeData.position).add(offset);
                newPlane.mesh.rotation.copy(planeData.rotation);
                newPlane.mesh.scale.copy(planeData.scale);
                newPlane.mesh.material.color.setHex(planeData.color);

                // Update plane data with correct values
                newPlane.width = planeData.width * planeData.scale.x;
                newPlane.height = planeData.height * planeData.scale.y;
                newPlane.defaultWidth = planeData.width;
                newPlane.defaultHeight = planeData.height;
                newPlane.x = newPlane.mesh.position.x;
                newPlane.y = newPlane.mesh.position.y;
                newPlane.z = newPlane.mesh.position.z;
                newPlane.angle = planeData.rotation.y * (180 / Math.PI);
                newPlane.incline = planeData.rotation.x * (180 / Math.PI);
                newPlane.color = planeData.color;
                newPlane.temperature = planeData.temperature;
                newPlane.type = planeData.type;
                newPlane.positive = planeData.positive !== undefined ? planeData.positive : true;

                // Select the new plane
                newPlanes.push(newPlane);
                newPlane.mesh.material.color.setHex(0xe3e3e3);
            });

            selectedPlanes = [...newPlanes];

            // If original was a group, recreate the group structure
            if (clipboard.isGroup && selectedPlanes.length > 1) {
                createOrUpdateGroup();

                // Apply relative positions if available
                if (clipboard.relativePositions) {
                    selectedPlanes.forEach((plane, index) => {
                        if (clipboard.relativePositions[index]) {
                            plane.mesh.position.copy(clipboard.relativePositions[index]);
                        }
                    });
                    updateGroupPosition();
                }
            }

            // Update transform controls and GUI
            updateTransformControls();
            if (selectedPlanes.length > 0) {
                // Force GUI update with the correct values
                const lastPlane = selectedPlanes[selectedPlanes.length - 1];
                updateGUI(lastPlane);

                // Also update the mesh's userData to match
                lastPlane.mesh.userData = lastPlane;
            }

            console.log('Pasted from clipboard');
            captureState("After paste");
        }


        // Function to apply contour texture to a plane automatically
        function applyContourTexture(plane) {
            if (!plane.contourData || !plane.contourData.values) {
                console.warn(`No contour data for plane: ${plane.name}`);
                return;
            }
            
            console.log(`Applying contour texture to ${plane.name}`);
            
            const contourData = plane.contourData;
            const n = contourData.width;
            const m = contourData.height;
            
            // Get user-defined color scale
            const { min, max } = getColorScaleValues();
            console.log(`Using color scale: ${min} to ${max}`);
            
            // Calculate SVG dimensions based on plane aspect ratio
            const planeAspectRatio = plane.width / plane.height;
            const planeArea = plane.width * plane.height;
            let baseSize = 512;
            if (planeArea > 25) {
                baseSize = Math.max(512, Math.round(Math.sqrt(planeArea) * 100));
            }
            
            let svgWidth, svgHeight;
            if (planeAspectRatio >= 1) {
                svgWidth = baseSize;
                svgHeight = Math.round(baseSize / planeAspectRatio);
            } else {
                svgHeight = baseSize;
                svgWidth = Math.round(baseSize * planeAspectRatio);
            }
            
            // Create SVG and generate contour
            const svg = d3.select("#contour-svg");
            svg.attr("width", svgWidth).attr("height", svgHeight);
            svg.selectAll("*").remove();
            
            const projection = d3.geoIdentity().fitSize([svgWidth, svgHeight], {
                type: "Polygon",
                coordinates: [[[0, 0], [n, 0], [n, m], [0, m], [0, 0]]]
            });
            
            const path = d3.geoPath().projection(projection);
            const contours = d3.contours().size([n, m]);
            const color = d3.scaleSequential(d3.interpolateTurbo).domain([min, max]);
            
            svg.append("g")
                .attr("stroke", "black")
                .selectAll()
                .data(color.ticks(20))
                .join("path")
                .attr("d", d => path(contours.contour(contourData.values, d)))
                .attr("fill", d => color(d));
            
            // Convert SVG to Canvas
            const canvas = document.createElement('canvas');
            canvas.width = svgWidth;
            canvas.height = svgHeight;
            const ctx = canvas.getContext('2d');
            
            const svgString = new XMLSerializer().serializeToString(svg.node());
            const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(svgBlob);
            
            const img = new Image();
            img.onload = function() {
                ctx.drawImage(img, 0, 0);
                URL.revokeObjectURL(url);
                
                // Create texture from canvas
                const texture = new THREE.CanvasTexture(canvas);
                texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter;
                texture.generateMipmaps = false;
                texture.flipY = false; // Flip texture vertically to match orientation
                
                // Mark as contour texture for state management
                texture.isContourTexture = true;
                texture.contourData = contourData.values;
                
                // Apply texture to plane
                plane.mesh.material.map = texture;
                plane.mesh.material.needsUpdate = true;
                plane.mesh.material.color.set(0xffffff); // Set to white so texture shows correctly
                
                console.log(`✅ Contour texture applied to ${plane.name}`);
            };
            img.onerror = function(err) {
                console.error(`Failed to load contour image for ${plane.name}:`, err);
            };
            img.src = url;
        }

        function showContourToSelectedPlane() {
            if (selectedPlanes.length === 0) {
                alert("Please select a receiver plane first");
                return;
            }

            const selectedPlane = selectedPlanes[0]; // Use the first selected plane
            
            // Check if this is a receiver plane with contour data
            if (selectedPlane.type !== "Receiver") {
                alert("Please select a receiver plane. Only receiver planes have contour data.");
                return;
            }
            
            if (!selectedPlane.contourData || !selectedPlane.contourData.values) {
                alert(`No contour data available for ${selectedPlane.name}. Please run Calculate first.`);
                return;
            }
            
            // Log actual data range vs color scale range
            const dataMin = Math.min(...selectedPlane.contourData.values);
            const dataMax = Math.max(...selectedPlane.contourData.values);
            const { min: userScaleMin, max: userScaleMax } = getColorScaleValues();
            
            console.log(`📊 Contour Data Analysis for "${selectedPlane.name}":`);
            console.log(`   Actual data range: ${dataMin.toFixed(3)} to ${dataMax.toFixed(3)}`);
            console.log(`   Color scale range: ${userScaleMin} to ${userScaleMax}`);
            
            if (dataMin < userScaleMin || dataMax > userScaleMax) {
                console.warn(`⚠️ Some data values are outside the color scale range!`);
                if (dataMin < userScaleMin) console.warn(`   ${(selectedPlane.contourData.values.filter(v => v < userScaleMin).length)} values below ${userScaleMin}`);
                if (dataMax > userScaleMax) console.warn(`   ${(selectedPlane.contourData.values.filter(v => v > userScaleMax).length)} values above ${userScaleMax}`);
            }

            // Get modal elements
            const modal = document.getElementById("contourModal");
            const modalImg = document.getElementById("contourImage");
            const valueDisplay = document.getElementById("valueDisplay");
            const span = document.getElementsByClassName("close")[0];

            // Use the selected plane's contour data
            const contourData = {
                width: selectedPlane.contourData.width,
                height: selectedPlane.contourData.height,
                values: selectedPlane.contourData.values
            };

            // Calculate SVG dimensions based on plane aspect ratio and size
            const planeAspectRatio = selectedPlane.width / selectedPlane.height;
            const planeArea = selectedPlane.width * selectedPlane.height;

            // Scale base size based on plane area to maintain texture quality
            // For larger planes, use higher resolution textures
            let baseSize = 512; // Minimum base size
            if (planeArea > 25) { // If plane area is larger than 5x5
                baseSize = Math.max(512, Math.round(Math.sqrt(planeArea) * 100)); // Scale with plane size
            }

            let svgWidth, svgHeight;

            if (planeAspectRatio >= 1) {
                // Plane is wider than tall
                svgWidth = baseSize;
                svgHeight = Math.round(baseSize / planeAspectRatio);
            } else {
                // Plane is taller than wide
                svgHeight = baseSize;
                svgWidth = Math.round(baseSize * planeAspectRatio);
            }

            // Update SVG dimensions
            const svg = d3.select("#contour-svg");
            svg.attr("width", svgWidth).attr("height", svgHeight);
            svg.selectAll("*").remove();

            const n = contourData.width;
            const m = contourData.height;

            // Use fitSize to properly scale the projection to the SVG dimensions
            const projection = d3.geoIdentity().fitSize([svgWidth, svgHeight], {
                type: "Polygon",
                coordinates: [[[0, 0], [n, 0], [n, m], [0, m], [0, 0]]]
            });

            const path = d3.geoPath().projection(projection);
            const contours = d3.contours().size([n, m]);
            
            // Get user-defined color scale
            const { min: colorMin, max: colorMax } = getColorScaleValues();
            const color = d3.scaleSequential(d3.interpolateTurbo).domain([colorMin, colorMax]);

            svg.append("g")
                .attr("stroke", "black")
                .selectAll()
                .data(color.ticks(20))
                .join("path")
                .attr("d", d => path(contours.contour(contourData.values, d)))
                .attr("fill", d => color(d));

            // Convert SVG to Canvas with matching dimensions
            const canvas = document.createElement('canvas');
            canvas.width = svgWidth;
            canvas.height = svgHeight;
            const ctx = canvas.getContext('2d');

            // Serialize SVG to string
            const svgString = new XMLSerializer().serializeToString(svg.node());
            const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(svgBlob);

            // Create image from SVG
            const img = new Image();
            img.onload = function () {
                ctx.drawImage(img, 0, 0);
                URL.revokeObjectURL(url);

                // Set the image source and show the modal
                modalImg.src = canvas.toDataURL();
                modal.style.display = "block";
                
                // Show color legend with user-defined scale and actual data range
                const dataMin = Math.min(...contourData.values);
                const dataMax = Math.max(...contourData.values);
                createColorLegend(colorMin, colorMax, 11, dataMin, dataMax);

                // Create value map from original data
                const valueMap = [];
                for (let y = 0; y < m; y++) {
                    valueMap[y] = [];
                    for (let x = 0; x < n; x++) {
                        valueMap[y][x] = contourData.values[y * n + x];
                    }
                }

                // Zoom variables
                let scale = 1;
                const minScale = 0.5;
                const maxScale = 5;
                const zoomFactor = 0.1;

                // Mouse wheel zoom handler
                function handleWheel(e) {
                    e.preventDefault();

                    // Calculate new scale
                    if (e.deltaY < 0) {
                        scale = Math.min(scale + zoomFactor, maxScale);
                    } else {
                        scale = Math.max(scale - zoomFactor, minScale);
                    }

                    // Apply the scale with vertical flip
                    modalImg.style.transform = `scale(${scale}, ${-scale})`;
                    modalImg.style.cursor = scale > 1 ? 'grab' : 'zoom-in';
                }

                // Mouse move handler to show values
                function handleMouseMove(e) {
                    const rect = modalImg.getBoundingClientRect();

                    // Calculate position relative to the image
                    const imgX = (e.clientX - rect.left) / rect.width;
                    const imgY = (e.clientY - rect.top) / rect.height;

                    if (imgX >= 0 && imgX <= 1 && imgY >= 0 && imgY <= 1) {
                        // Map to data coordinates (flip Y because image is flipped)
                        const dataX = Math.floor(imgX * n);
                        const dataY = Math.floor((1 - imgY) * m);

                        // Clamp to valid range
                        const x = Math.max(0, Math.min(n - 1, dataX));
                        const y = Math.max(0, Math.min(m - 1, dataY));

                        const value = valueMap[y][x];

                        // Position display above cursor when near bottom
                        const displayAbove = (e.clientY > window.innerHeight - 100);

                        valueDisplay.style.display = 'block';
                        valueDisplay.style.left = `${e.clientX + 15}px`;
                        valueDisplay.style.top = `${e.clientY + (displayAbove ? -40 : 15)}px`;
                        valueDisplay.textContent = `Value: ${value.toFixed(2)}`;
                    } else {
                        valueDisplay.style.display = 'none';
                    }
                }

                // Mouse leave handler
                function handleMouseLeave() {
                    valueDisplay.style.display = 'none';
                }

                // Add event listeners
                modalImg.addEventListener('wheel', handleWheel, { passive: false });
                modalImg.addEventListener('mousemove', handleMouseMove);
                modalImg.addEventListener('mouseleave', handleMouseLeave);

                // Cleanup function
                function cleanup() {
                    modalImg.removeEventListener('wheel', handleWheel);
                    modalImg.removeEventListener('mousemove', handleMouseMove);
                    modalImg.removeEventListener('mouseleave', handleMouseLeave);
                    modal.style.display = "none";
                    modalImg.style.transform = 'scaleY(-1)';
                    scale = 1; // Reset scale
                }

                // Close handlers
                span.onclick = cleanup;
                modal.onclick = function (e) {
                    if (e.target === modal) cleanup();
                };
                modalImg.onclick = function (e) {
                    e.stopPropagation();
                };
                
                // Prevent closing when clicking on color legend
                document.getElementById('colorLegend').onclick = function(e) {
                    e.stopPropagation();
                };
            };
            img.src = url;
        }

        // Add event listener to your contour button
        
        document.getElementById("detail").addEventListener("click", showContourToSelectedPlane);



        // Updated captureState function to handle all plane properties and new functionality
        function captureState(description = "User action") {
            // Don't capture during operations unless forced
            if (transformControlss && transformControlss.dragging) return;

            const state = {
                planes: planes.map(plane => ({
                    id: plane.id || generateId(), // Add unique IDs
                    position: plane.mesh.getWorldPosition(new THREE.Vector3()).clone(), // Store world position instead of local
                    rotation: plane.mesh.rotation.clone(),
                    scale: plane.mesh.scale.clone(),
                    width: plane.width,
                    height: plane.height,
                    // Store default values for reset functionality
                    defaultWidth: plane.defaultWidth,
                    defaultHeight: plane.defaultHeight,
                    defaultX: plane.defaultX,
                    defaultY: plane.defaultY,
                    defaultZ: plane.defaultZ,
                    defaultAngle: plane.defaultAngle,
                    defaultColor: plane.defaultColor,
                    // Store derived properties
                    x: plane.x,
                    y: plane.y,
                    z: plane.z,
                    angle: plane.angle,
                    incline: plane.incline,
                    color: plane.color,
                    temperature: plane.temperature,
                    type: plane.type,
                    name: plane.name,
                    selected: selectedPlanes.includes(plane),
                    // Store material properties including texture information
                    hasTexture: plane.mesh.material.map !== null,
                    textureData: plane.mesh.material.map ? {
                        isContourTexture: plane.mesh.material.map.isContourTexture || false,
                        contourData: plane.mesh.material.map.contourData || null
                    } : null
                })),
                groups: selectedPlaneGroup ? {
                    planeIds: selectedPlanes.map(p => p.id),
                    position: selectedPlaneGroup.position.clone(),
                    rotation: selectedPlaneGroup.rotation.clone(),
                    scale: selectedPlaneGroup.scale.clone()
                } : null,
                // Store scene state
                imagePlane: {
                    visible: imagePlane.visible,
                    position: imagePlane.position.clone(),
                    rotation: imagePlane.rotation.clone(),
                    scale: imagePlane.scale.clone(),
                    geometry: {
                        width: imagePlane.geometry.parameters.width,
                        height: imagePlane.geometry.parameters.height
                    }
                },
                // Store contour data if available
                contourData: dataarrayforcontour ? {
                    values: dataarrayforcontour,
                    timestamp: Date.now()
                } : null,
                description: description,
                timestamp: Date.now(),
                isPasteOperation: typeof description === 'string' && (description.includes("paste") || description.includes("Paste"))
            };

            // Trim history if needed
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }

            // Skip duplicate states
            if (history.length > 0) {
                const last = history[history.length - 1];
                if (JSON.stringify(last) === JSON.stringify(state)) return;
            }

            history.push(state);
            historyIndex = history.length - 1;

            // Limit history size
            if (history.length > MAX_HISTORY_STEPS) {
                history.shift();
                historyIndex--;
            }

            console.log(`State captured: ${description} - Total planes: ${planes.length}, Selected: ${selectedPlanes.length}`);
            console.log(`Plane IDs in state: ${state.planes.map(p => p.id).join(', ')}`);
        }


        // Remove duplicate event listener - this functionality is already handled in the main dragging-changed listener

        // Updated restoreState function to handle all plane properties and new functionality
        function restoreState(index) {
            if (index < 0 || index >= history.length) return;

            const state = history[index];
            console.log(`Restoring state: ${state.description || 'Unknown'}`);

            // Clear current selection and groups
            selectedPlanes = [];
            if (selectedPlaneGroup) {
                ungroupPlanes();
            }

            // First pass: update existing planes or create new ones
            const newPlanes = [];
            state.planes.forEach(planeState => {
                let plane = planes.find(p => p.id === planeState.id);

                if (!plane) {
                    // Create new plane
                    plane = createPlane(planeState.width, planeState.height);
                    plane.id = planeState.id;
                    console.log(`Created new plane with ID: ${planeState.id}`);
                } else {
                    console.log(`Found existing plane with ID: ${planeState.id}`);
                }

                // Ensure the plane is in the scene
                if (!scene.children.includes(plane.mesh)) {
                    scene.add(plane.mesh);
                }

                // For paste operations, ensure we're restoring to the exact state
                if (state.isPasteOperation) {
                    console.log(`Restoring paste operation state for plane ${planeState.id}`);
                }

                // Update all plane properties including defaults
                if (planeState.defaultWidth !== undefined) plane.defaultWidth = planeState.defaultWidth;
                if (planeState.defaultHeight !== undefined) plane.defaultHeight = planeState.defaultHeight;
                if (planeState.defaultX !== undefined) plane.defaultX = planeState.defaultX;
                if (planeState.defaultY !== undefined) plane.defaultY = planeState.defaultY;
                if (planeState.defaultZ !== undefined) plane.defaultZ = planeState.defaultZ;
                if (planeState.defaultAngle !== undefined) plane.defaultAngle = planeState.defaultAngle;
                if (planeState.defaultColor !== undefined) plane.defaultColor = planeState.defaultColor;

                // Update current properties
                plane.mesh.rotation.copy(planeState.rotation);
                plane.mesh.scale.copy(planeState.scale);
                plane.width = planeState.width;
                plane.height = planeState.height;
                plane.color = planeState.color;
                plane.temperature = planeState.temperature;
                plane.type = planeState.type;
                plane.name = planeState.name;
                plane.positive = planeState.positive !== undefined ? planeState.positive : true;
                plane.mesh.material.color.setHex(planeState.color);

                // Update derived properties
                plane.x = planeState.position.x;
                plane.y = planeState.position.y;
                plane.z = planeState.position.z;
                plane.angle = planeState.rotation.y * (180 / Math.PI);
                plane.incline = planeState.rotation.x * (180 / Math.PI);

                // Handle texture restoration if available
                if (planeState.hasTexture && planeState.textureData) {
                    if (planeState.textureData.isContourTexture && planeState.textureData.contourData) {
                        // Restore contour texture
                        restoreContourTexture(plane, planeState.textureData.contourData);
                    }
                }

                if (planeState.selected) {
                    selectedPlanes.push(plane);
                    plane.mesh.material.color.setHex(0xe3e3e3);
                } else {
                    plane.mesh.material.color.setHex(plane.color);
                }

                newPlanes.push(plane);
            });

            // Remove planes that shouldn't exist in this state
            const planesToRemove = planes.filter(p => !state.planes.some(s => s.id === p.id));
            planesToRemove.forEach(plane => {
                console.log(`Removing plane with ID: ${plane.id}`);
                if (scene.children.includes(plane.mesh)) {
                    scene.remove(plane.mesh);
                }
                plane.mesh.geometry.dispose();
                plane.mesh.material.dispose();
            });

            // Update planes array
            planes.splice(0, planes.length, ...newPlanes);

            // Set positions for all planes first (before grouping)
            newPlanes.forEach(plane => {
                const planeState = state.planes.find(p => p.id === plane.id);
                if (planeState) {
                    plane.mesh.position.copy(planeState.position);
                    console.log(`Set plane ${plane.id} position to: ${planeState.position}`);
                }
            });

            // Restore group if needed
            if (state.groups) {
                selectedPlanes = planes.filter(p => state.groups.planeIds.includes(p.id));

                // Create group without calling captureState (we'll do it manually)
                if (!selectedPlaneGroup) {
                    selectedPlaneGroup = new THREE.Group();
                    scene.add(selectedPlaneGroup);
                    originalPositions = new Map();
                }

                // Clear existing planes from group
                while (selectedPlaneGroup.children.length > 0) {
                    selectedPlaneGroup.remove(selectedPlaneGroup.children[0]);
                }

                // Add planes to group and store their original positions
                selectedPlanes.forEach(plane => {
                    const planeState = state.planes.find(p => p.id === plane.id);
                    if (planeState) {
                        // Store original world position
                        originalPositions.set(plane, {
                            worldPosition: planeState.position.clone(),
                            parent: scene
                        });

                        // Add to group (position is already set)
                        selectedPlaneGroup.add(plane.mesh);

                        console.log(`Added plane ${plane.id} to group with position: ${plane.mesh.position}`);
                    }
                });

                // Set group position
                selectedPlaneGroup.position.copy(state.groups.position);
                selectedPlaneGroup.rotation.copy(state.groups.rotation);
                selectedPlaneGroup.scale.copy(state.groups.scale);

                console.log(`Set group position to: ${state.groups.position}`);
            }

            // Restore image plane state if available
            if (state.imagePlane) {
                imagePlane.visible = state.imagePlane.visible;
                imagePlane.position.copy(state.imagePlane.position);
                imagePlane.rotation.copy(state.imagePlane.rotation);
                imagePlane.scale.copy(state.imagePlane.scale);

                // Update geometry if dimensions changed
                if (state.imagePlane.geometry) {
                    imagePlane.geometry.dispose();
                    imagePlane.geometry = new THREE.PlaneGeometry(
                        state.imagePlane.geometry.width,
                        state.imagePlane.geometry.height
                    );
                }
            }

            // Restore contour data if available
            if (state.contourData && state.contourData.values) {
                dataarrayforcontour = state.contourData.values;
                console.log(`Restored contour data with ${dataarrayforcontour.length} values`);
            }

            // Update GUI and controls
            updateTransformControls();
            if (selectedPlanes.length > 0) {
                updateGUI(selectedPlanes[selectedPlanes.length - 1]);
            }

            // Update GUI
            gui.destroy();
            gui = new dat.GUI();

            console.log(`State restoration complete. Total planes: ${planes.length}, Selected: ${selectedPlanes.length}`);
            console.log(`Current plane IDs: ${planes.map(p => p.id).join(', ')}`);
            console.log(`Selected plane IDs: ${selectedPlanes.map(p => p.id).join(', ')}`);

            // Debug: Log final positions of all planes
            planes.forEach(plane => {
                const worldPos = plane.mesh.getWorldPosition(new THREE.Vector3());
                console.log(`Final plane ${plane.id}: local=${plane.mesh.position}, world=${worldPos}`);
            });

            if (selectedPlaneGroup) {
                console.log(`Group position: ${selectedPlaneGroup.position}`);
                console.log(`Group children: ${selectedPlaneGroup.children.length}`);
            }
        }

        // Helper function to restore contour textures
        function restoreContourTexture(plane, contourData) {
            try {
                // Create a new canvas with the contour data
                const gridWidth = Math.round(plane.width) * 2;
                const gridHeight = Math.round(plane.height) * 2;

                // Calculate SVG dimensions based on plane aspect ratio
                const planeAspectRatio = plane.width / plane.height;
                let baseSize = 512;
                if (plane.width * plane.height > 25) {
                    baseSize = Math.max(512, Math.round(Math.sqrt(plane.width * plane.height) * 100));
                }

                let svgWidth, svgHeight;
                if (planeAspectRatio >= 1) {
                    svgWidth = baseSize;
                    svgHeight = Math.round(baseSize / planeAspectRatio);
                } else {
                    svgHeight = baseSize;
                    svgWidth = Math.round(baseSize * planeAspectRatio);
                }

                // Create SVG and generate contour
                const svg = d3.select("#contour-svg");
                svg.attr("width", svgWidth).attr("height", svgHeight);
                svg.selectAll("*").remove();

                const n = gridWidth;
                const m = gridHeight;

                const projection = d3.geoIdentity().fitSize([svgWidth, svgHeight], {
                    type: "Polygon",
                    coordinates: [[[0, 0], [n, 0], [n, m], [0, m], [0, 0]]]
                });

                const path = d3.geoPath().projection(projection);
                const contours = d3.contours().size([n, m]);
                
                // Get user-defined color scale
                const { min, max } = getColorScaleValues();
                const color = d3.scaleSequential(d3.interpolateTurbo).domain([min, max]);

                svg.append("g")
                    .attr("stroke", "black")
                    .selectAll()
                    .data(color.ticks(20))
                    .join("path")
                    .attr("d", d => path(contours.contour(contourData, d)))
                    .attr("fill", d => color(d));

                // Convert SVG to texture
                const canvas = document.createElement('canvas');
                canvas.width = svgWidth;
                canvas.height = svgHeight;
                const ctx = canvas.getContext('2d');

                const svgString = new XMLSerializer().serializeToString(svg.node());
                const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(svgBlob);

                const img = new Image();
                img.onload = function () {
                    ctx.drawImage(img, 0, 0);
                    URL.revokeObjectURL(url);

                    const texture = new THREE.CanvasTexture(canvas);
                    texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.generateMipmaps = false;
                    texture.flipY = false; // Flip texture vertically to match orientation

                    // Mark as contour texture for future state captures
                    texture.isContourTexture = true;
                    texture.contourData = contourData;

                    plane.mesh.material.map = texture;
                    plane.mesh.material.needsUpdate = true;
                    plane.mesh.material.color.set(0xffffff);

                    console.log(`Restored contour texture for plane ${plane.id}`);
                };
                img.src = url;
            } catch (error) {
                console.error(`Error restoring contour texture for plane ${plane.id}:`, error);
            }
        }



        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, activeCamera);
            labelRenderer.render(scene, activeCamera);
        }
        animate();

        // Test backend connection when page loads
        testBackendConnection();

        // Handle window resize
        window.addEventListener("resize", () => {
            cameras.perspective.aspect = window.innerWidth / window.innerHeight;
            cameras.perspective.updateProjectionMatrix();
            activeCamera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            updateOrthoCameras();

            // Update transform controls if they exist
            if (transformControlss) {
                transformControlss.camera = activeCamera;
            }
        });
    </script>
</body>

</html>
